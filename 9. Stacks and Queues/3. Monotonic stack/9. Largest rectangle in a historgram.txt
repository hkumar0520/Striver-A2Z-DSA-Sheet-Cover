

class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int len = heights.size(), maxArea = 0;

        // for every block check prev smaller and next smaller, then get area
        for(int i = 0 ; i<len; i++){

            int prev = i;
            for(int j = i-1; j>=0; j--){
                if(heights[j] < heights[i])
                    break;
                prev = j;
            }

            int next = i;
            for(int j = i+1; j<len; j++){
                if(heights[j] < heights[i])
                    break;
                next = j;
            }
            maxArea = max(maxArea, (next - prev + 1) * heights[i]);
        }
        return maxArea;
    }
};

TC: O(n*n)
SC: O(1)


##########################################################################################



class Solution {
public:
    // index earlier than prev smaller
    // increasing stack 
    vector<int> findPrevSmaller(vector<int>& heights){
        int len = heights.size();
        stack<int> st;
        vector<int> ans(len, -1);
        for(int i = 0; i<len; i++){
            if(st.empty())
                st.push(i);
            else{

                while(!st.empty() && heights[st.top()] >= heights[i])
                    st.pop();
                if(!st.empty())
                    ans[i] = st.top() + 1;
                
                st.push(i);
            }
        }
        // if no prev smaller found, then assign 0 index
        for(int i = 0; i<len; i++){
            if(ans[i] == -1)
                ans[i] = 0;
        }
        return ans;
    }
    
    // index of element before next smaller element
    // increasing stack 
    vector<int> findNextSmaller(vector<int>& heights){
        int len = heights.size();
        vector<int> ans(len, -1);
        stack<int> st;
        for(int i = 0; i<len; i++){
            while(!st.empty() && heights[st.top()] > heights[i]){
                ans[st.top()] = i-1;
                st.pop();
            }
            st.push(i);
        }
        // if no next smaller found assign len-1
        for(int i = 0; i<len; i++){
            if(ans[i] == -1)
                ans[i] = len-1;
        }
        return ans;
    }
    int largestRectangleArea(vector<int>& heights) {
        int len = heights.size(), maxArea = 0;

        vector<int> prevSmaller = findPrevSmaller(heights);
        vector<int> nextSmaller = findNextSmaller(heights);

        // for every block check prev smaller, then get area
        for(int i = 0 ; i<len; i++){
            int prev = prevSmaller[i];
            int next = nextSmaller[i];
            maxArea = max(maxArea, (next - prev + 1) * heights[i]);
        }
        return maxArea;
    }
};

TC: O(3n) + O(3n) + O(n)
SC: O(2n) + O(2n) 




###################################################################################



class Solution {
public:
    // index earlier than prev smaller
    // increasing stack 
    vector<int> findPrevSmaller(vector<int>& heights){
        int len = heights.size();
        stack<int> st;
        vector<int> ans(len, 0);
        for(int i = 0; i<len; i++){
            while(!st.empty() && heights[st.top()] >= heights[i])
                st.pop();
            if(!st.empty())
                ans[i] = st.top() + 1;
            
            st.push(i);
        }

        return ans;
    }
    
    // index of element before next smaller element
    // increasing stack 
    vector<int> findNextSmaller(vector<int>& heights){
        int len = heights.size();
        vector<int> ans(len, len-1);
        stack<int> st;
        for(int i = 0; i<len; i++){
            while(!st.empty() && heights[st.top()] > heights[i]){
                ans[st.top()] = i-1;
                st.pop();
            }
            st.push(i);
        }

        return ans;
    }
    int largestRectangleArea(vector<int>& heights) {
        int len = heights.size(), maxArea = 0;

        vector<int> prevSmaller = findPrevSmaller(heights);
        vector<int> nextSmaller = findNextSmaller(heights);

        // for every block check prev smaller, then get area
        for(int i = 0 ; i<len; i++){
            int prev = prevSmaller[i];
            int next = nextSmaller[i];
            maxArea = max(maxArea, (next - prev + 1) * heights[i]);
        }
        return maxArea;
    }
};


TC: O(2n) + O(2n) + O(n)
SC: O(2n) + O(2n) 



############################################################################################




class Solution {
public:
    // stictly increasing
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        int len = heights.size(), maxAreaRectangle = INT_MIN;
        
        for(int i = 0; i < len; i++){
            while(!st.empty() && heights[st.top()] >= heights[i]){
                int element = heights[st.top()];
                st.pop();
                int prev = st.empty() ? 0 : st.top() + 1;
                int next = i-1;
                maxAreaRectangle = max(maxAreaRectangle, element*(next - prev + 1));
            }
            st.push(i);
        }
        while(!st.empty()){
            int element = heights[st.top()];
            st.pop();
            int prev = st.empty() ? 0 : st.top() + 1;
            int next = len - 1;
            maxAreaRectangle = max(maxAreaRectangle, element*(next - prev + 1));
        }
        return maxAreaRectangle;
    }
};

TC: O(2n)
SC: O(n)




