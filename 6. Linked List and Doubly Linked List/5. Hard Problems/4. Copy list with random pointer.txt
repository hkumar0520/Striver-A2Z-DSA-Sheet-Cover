



/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        Node* current =  head;
        
        // add the nodes
        while(current != nullptr){
            Node* nextNode = current->next;
            Node* copyNode = new Node(current->val);;
            current->next = copyNode;
            copyNode->next = nextNode;

            current = nextNode;
        }


        //copy the random pointer
        current = head;
        while(current != nullptr){
            if(current->random != nullptr){
                current->next->random = current->random->next;
            }
            current = current->next->next;
        }

        //detach the linked List
        Node* newHead = new Node(-1);
        Node* copyList = newHead;
        current = head;

        while(current != nullptr){
            Node* copyNode = current->next;
            copyList->next = copyNode;
            copyList = copyList->next;

            current->next = current->next->next;
            current = current->next;
        }

        return newHead->next;
    }
};


TC: O(3n)
SC: O(n)

Let's analyze the **time and space complexity** of the provided C++ solution to **Leetcode 138: Copy List with Random Pointer**.

---

### âœ… **Code Recap (High-Level Steps)**

1. **Clone Nodes & Insert Next to Originals**
   Traverse the list and insert each cloned node right after its original.
   â†’ Time: O(n), Space: O(1)

2. **Set Random Pointers**
   Traverse the modified list again and assign random pointers for the clones.
   â†’ Time: O(n), Space: O(1)

3. **Separate the Lists**
   Detach the cloned list from the interleaved structure.
   â†’ Time: O(n), Space: O(1)

Let **n** be the number of nodes in the original list.

---

### â±ï¸ **Time Complexity: `O(n)`**

* Each of the three steps traverses the list once.
* Every operation inside those loops is **O(1)**.
* So the total time is: **O(n)**.

---

### ðŸ§  **Space Complexity: `O(1)` (Auxiliary)**

* No **extra data structures** like hash maps are used.
* New nodes are created for the deep copy, but that **doesnâ€™t count** toward auxiliary space â€” itâ€™s part of the required output.

âœ… So auxiliary space: **O(1)**

> If you were using a `hashmap<Node*, Node*>`, it would have been O(n) space.

---

### âœ… Final Answer:

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)` (auxiliary)

Let me know if you want the hashmap-based approach analyzed or implemented as well.



