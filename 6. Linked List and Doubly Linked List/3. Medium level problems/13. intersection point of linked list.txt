

1. Brute force(m*n, 1)
2. Better (m+n, m)
3. Optimal (2m+n, 1)
3. Optimal (m+n, 1)
5. Optimal (3m+n, 1)


class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        while(headA != nullptr){
            ListNode* current = headB;
            while(current != nullptr){
                if(current == headA)    return current;
                current = current->next;
            }
            headA = headA->next;
        }
        return nullptr;
    }
};

TC: O(m*N)
SC: (1)


#########################################################################################################################################

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        map<ListNode*, int> mp;
        ListNode* current = headA;
        while(current != nullptr){
            mp[current] = 1;
            current = current->next;
        }

        current = headB;
        while(current != nullptr){
            if(mp.find(current) != mp.end()) return current;
            current = current->next;
        }

        return nullptr;
    }
};

TC: O(m+n)
SC: O(m)


#########################################################################################################################################


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    int getDifference(ListNode* headA, ListNode* headB){
        int lenA = 0, lenB = 0;
        while(headA != nullptr){
            headA = headA ->next;
            lenA++;
        }
        while(headB != nullptr){
            headB = headB ->next;
            lenB++;
        }
        return lenA - lenB;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int diff = getDifference(headA, headB);
        if(diff < 0){
            while(diff++ != 0)  headB = headB->next;
        }
        else{
            while(diff-- != 0)  headA = headA->next;
        }

        while(headA != nullptr && headB != nullptr){
            if(headA == headB)  return headA;
            headA = headA->next;
            headB = headB->next;
        }
        return nullptr;
    }
};


TC: O(m+n + max(m,n))
SC: O(1)



#########################################################################################################################################

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* currentA = headA, *currentB = headB;
        int cnt = 0;
        while(currentA != currentB){
            if(currentA == nullptr){
                currentA = headB;
                cnt++;
            }
            else
                currentA = currentA->next;
            
            if(currentB == nullptr){
                currentB = headA;
                cnt++;
            }
            else
                currentB = currentB->next;

            if(cnt >= 3)    return nullptr;

        }
        return currentA;
    }
};


TC: O(m+n)
SC: O(1)







#########################################################################################################################################



/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseLinkedList(ListNode* head){
        ListNode* prev = nullptr, *current = head;
        while(current != nullptr){
            ListNode* frontNode = current->next;

            current->next = prev;
            prev = current;
            current = frontNode;
        }
        return prev;
    }
    ListNode* findIntersectioPoint(ListNode *head) {
        ListNode* slow = head, *fast = head;

        while(fast != nullptr && fast->next != nullptr){
            slow = slow->next;
            fast = fast->next->next;

            if(slow == fast){
                slow = head;
                while(slow != fast){
                    slow = slow->next;
                    fast = fast->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* newHeadA = reverseLinkedList(headA);
        headA->next = headB;

        ListNode* intersectionPoint = findIntersectioPoint(newHeadA);
        headA->next = nullptr;

        headA = reverseLinkedList(newHeadA);
        return intersectionPoint;
    }
};

/*
lenA = m
lenB = n;

TC: m + (m+n) + m : O(3m + n)
SC: O(1)

*/


