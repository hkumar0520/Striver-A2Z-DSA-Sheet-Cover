

class Solution
{
    public:
    //Function to merge k sorted arrays.
    vector<int> mergeKArrays(vector<vector<int>> arr, int K)
    {
        //code here
        priority_queue< vector<int>, vector<vector<int>>,
                        greater<vector<int>> > pq;

        // O(K)                
        for(int i=0; i<K;i++)
            pq.push(arr[i]);       // logk
        
        vector<int> ans;
        while(!pq.empty()){
            vector<int> curr = pq.top();
            pq.pop();
            
            ans.push_back(curr[0]);
            curr.erase(curr.begin()+0);
            if(curr.size() != 0)
                pq.push(curr);
        }
        return  ans;
    }
};

Let's analyze the time and space complexity of the provided C++ code, which merges `k` sorted arrays using a **min-heap** (priority queue).

### Code Explanation:

1. **Priority Queue**: A priority queue (min-heap) is used to keep track of the smallest elements across all `k` sorted arrays.
   
2. **Pushing arrays into the heap**:
   - The code pushes each of the `k` arrays into the priority queue initially. The priority queue is configured to compare vectors based on their first element using the custom comparator `greater<vector<int>>`, which ensures the smallest array (based on the first element) is at the top.

3. **Merging process**:
   - After inserting the `k` arrays into the priority queue, the algorithm pops the smallest array (based on the first element), adds the first element to the result vector `ans`, and then removes the first element from that array.
   - If the array still has remaining elements after removing the first one, the array is pushed back into the priority queue with the updated elements.
   - This continues until the priority queue is empty, meaning all elements from all arrays have been processed.

### Time Complexity:

1. **Inserting Arrays into the Priority Queue**:
   - We are inserting each of the `k` arrays into the priority queue.
   - The priority queue stores `k` arrays, and each insertion involves comparing the first element of the array.
   - The time complexity for inserting an element into a priority queue is **O(log k)**.
   - Therefore, inserting `k` arrays into the priority queue will take **O(k log k)** time.

2. **Merging the Arrays**:
   - The total number of elements across all `k` arrays is `n`, where `n` is the sum of the lengths of the arrays.
   - Each time we pop an array from the priority queue, we extract the first element (constant time operation), and then we re-insert the array back into the queue (if it still has elements left).
   - In the worst case, we pop and re-insert elements `n` times (since there are `n` total elements).
   - Each re-insertion into the priority queue takes **O(log k)** time.
   - Therefore, the time complexity for the merging step is **O(n log k)**.

3. **Total Time Complexity**:
   - The overall time complexity is the sum of the time taken for the initial insertions and the time taken for merging:
     - **O(k log k)** for inserting the `k` arrays.
     - **O(n log k)** for merging all elements.
   - The total time complexity is: **O(k log k + n log k)**.

### Space Complexity:

1. **Priority Queue**:
   - The priority queue stores up to `k` arrays, each of which can have multiple elements. However, at any given time, the priority queue will store only one array at a time from each of the `k` arrays.
   - Therefore, the space used by the priority queue is **O(k)**, where `k` is the number of arrays.

2. **Result Vector**:
   - The result vector `ans` will store all `n` elements, where `n` is the sum of the lengths of the `k` arrays.
   - Therefore, the space complexity for the result vector is **O(n)**.

3. **Auxiliary Space**:
   - There is no significant auxiliary space beyond the priority queue and the result vector.

### Total Space Complexity:
- The space complexity is the sum of:
  - **O(k)** for the priority queue.
  - **O(n)** for the result vector.
- Thus, the total space complexity is: **O(n + k)**.

### Final Conclusion:

- **Time Complexity**: **O(k log k + n log k)**, where:
  - `k` is the number of arrays.
  - `n` is the total number of elements across all arrays.
  
- **Space Complexity**: **O(n + k)**, where:
  - `n` is the total number of elements across all arrays.
  - `k` is the number of arrays.




##############################################################################





To solve the problem of merging `k` sorted arrays, we can efficiently use a **min-heap** (priority queue). Here's a step-by-step breakdown of the approach:

### Approach:
1. **Min-Heap (Priority Queue):**
   - We can use a min-heap to extract the smallest elements from all the `k` sorted arrays.
   - The idea is to insert the first element from each array into the min-heap. After each extraction of the minimum element, we replace it with the next element from the same array (if any).
   - This ensures that at each step, the smallest element from all the arrays is available for extraction, and we can maintain the merged order.

2. **Heap Structure:**
   - Each element in the heap is a tuple containing:
     - The value of the element.
     - The index of the array from which it came.
     - The index of the element within that array.
   - This allows us to track from which array and position the element came, so we can efficiently replace it with the next element from the same array.

### Steps:
1. Push the first element of each array into the heap.
2. While the heap is not empty, extract the minimum element (the root), add it to the merged result, and then insert the next element from the same array (if any) into the heap.
3. Continue this process until all elements have been processed.

### Time Complexity:
- **Heap Operations:** Inserting and extracting from the heap takes **O(log k)** time, where `k` is the number of arrays.
- Since there are `k^2` elements in total (because each array has `k` elements), the total time complexity is **O(k^2 * log k)**.

### Space Complexity:
- The heap stores up to `k` elements at any given time, so the space complexity is **O(k)**.

### C++ Code Implementation:

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// A structure to represent an element in the heap
struct Element {
    int value;   // Value of the element
    int row;     // Row index from where the element came
    int col;     // Column index of the element in that row
    
    // Constructor
    Element(int v, int r, int c) : value(v), row(r), col(c) {}
    
    // Comparator for the priority queue (min-heap)
    bool operator>(const Element& e) const {
        return value > e.value; // Min-heap based on value
    }
};

vector<int> mergeKSortedArrays(vector<vector<int>>& arr) {
    int k = arr.size();
    priority_queue<Element, vector<Element>, greater<Element>> minHeap;
    vector<int> result;
    
    // Step 1: Push the first element of each array into the heap
    for (int i = 0; i < k; ++i) {
        minHeap.push(Element(arr[i][0], i, 0));
    }
    
    // Step 2: Extract the minimum element and insert the next element from the same array
    while (!minHeap.empty()) {
        Element minElem = minHeap.top();
        minHeap.pop();
        
        // Add the minimum element to the result
        result.push_back(minElem.value);
        
        // If there are more elements in the same array, insert the next one
        if (minElem.col + 1 < k) {
            minHeap.push(Element(arr[minElem.row][minElem.col + 1], minElem.row, minElem.col + 1));
        }
    }
    
    return result;
}

int main() {
    // Example 1
    vector<vector<int>> arr1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    vector<int> result1 = mergeKSortedArrays(arr1);
    cout << "Merged array: ";
    for (int num : result1) {
        cout << num << " ";
    }
    cout << endl;

    // Example 2
    vector<vector<int>> arr2 = {{1, 2, 3, 4}, {2, 2, 3, 4}, {5, 5, 6, 6}, {7, 8, 9, 9}};
    vector<int> result2 = mergeKSortedArrays(arr2);
    cout << "Merged array: ";
    for (int num : result2) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

### Explanation of the Code:
1. **Element Structure:**
   - We define a custom `Element` structure that holds the value of the element, the row index, and the column index. This is required to track which array and position the element came from.

2. **Min-Heap:**
   - We use `std::priority_queue` with a custom comparator to implement the min-heap. The heap is ordered based on the values of the elements, ensuring that the smallest element is always at the top.
   
3. **Main Function:**
   - The `mergeKSortedArrays` function initializes the heap by inserting the first element from each of the `k` arrays.
   - Then, it extracts the minimum element from the heap, adds it to the result array, and inserts the next element from the same array into the heap.
   - This process continues until all elements have been merged.

### Example 1:

Input:
```cpp
arr1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
```

Output:
```
Merged array: 1 2 3 4 5 6 7 8 9
```

### Example 2:

Input:
```cpp
arr2 = {{1, 2, 3, 4}, {2, 2, 3, 4}, {5, 5, 6, 6}, {7, 8, 9, 9}}
```

Output:
```
Merged array: 1 2 2 2 3 3 4 4 5 5 6 6 7 8 9 9
```

### Time and Space Complexity:
k = size of arr, k = size of vector of arr 
- **Time Complexity:** O(k² * log k) because we process each element (k² elements) and perform a heap operation (insert or extract) for each element, which takes O(log k) time.
- **Space Complexity:** O(k), as the heap stores at most `k` elements at any time.

This approach efficiently merges `k` sorted arrays into one sorted array.