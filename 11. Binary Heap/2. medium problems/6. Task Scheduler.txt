

class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> map(26, 0);

        for(int i=0; i<tasks.size(); i++){
            map[tasks[i] - 'A']++;
        }

        priority_queue<pair<int,int>> pq;
        for(int i=0; i<26; i++){
            if(map[i] != 0){
                pq.push({map[i], i});
            }
        }

        int countPossibleSequence = 0;
        while(!pq.empty()){
            int countN = n+1;
            priority_queue<pair<int,int>> pqtemp;

            while(countN>0){
                if(!pq.empty()){
                    pair<int,int> curr = pq.top();
                    pq.pop();

                    curr.first = curr.first - 1;
                    if(curr.first != 0)
                        pqtemp.push(curr);
                    countN--;
                    countPossibleSequence++;
                    continue;
                }

                // reached end
                if(pqtemp.empty())
                    break;
            
                countN--;
                countPossibleSequence++;
            }

            while(!pqtemp.empty()){
                pq.push(pqtemp.top());
                pqtemp.pop();
            }
        }
        return countPossibleSequence;
    }
};


Let's analyze the time and space complexity of the given code step-by-step.

### Code Overview:

This code implements a task scheduler where you are given a list of tasks and a cooldown period `n`. The objective is to find the least number of intervals required to complete all the tasks, with the restriction that no two tasks of the same type can be executed in the same interval unless they are spaced by at least `n` intervals.

The approach uses:
- **Priority Queue**: To always pick the task with the highest frequency (greedy approach).
- **Temp Priority Queue**: To manage the tasks while respecting the cooldown period `n`.

### Time Complexity:

1. **Counting Task Frequencies**:
   - The `map` vector of size 26 (for the 26 uppercase English letters) is populated by iterating through the `tasks` vector.
   - The size of the `tasks` vector is `T`.
   - **Time complexity for this step**: **O(T)**, where `T` is the number of tasks.

2. **Building the Priority Queue**:
   - After populating the task frequencies, the code builds the initial priority queue by pushing the frequency of each task into the priority queue.
   - Since there are at most 26 unique tasks, the number of elements in the priority queue will be at most 26.
   - **Time complexity for this step**: **O(26 log 26)**, which simplifies to **O(1)** because 26 is constant.

3. **Processing the Tasks**:
   - The main part of the code involves repeatedly extracting tasks from the priority queue and scheduling them, while maintaining a cooldown period of `n`. This continues until all tasks are scheduled.
   - In each iteration, a batch of tasks (up to `n + 1` tasks) is processed. Each extraction and insertion from/to the priority queue takes **O(log k)** time, where `k` is the number of tasks in the priority queue.
   - In the worst case, the number of iterations can be proportional to the total number of tasks, `T`. The `while` loop runs until all tasks are scheduled, which could take **O(T)** steps.
   - Each operation inside the loop involves pushing and popping from a priority queue, both of which take **O(log k)** time, where `k` is at most 26 (the number of unique tasks).
   - **Time complexity for processing tasks**: In the worst case, this takes **O(T log k)**, where `k` is at most 26, so this simplifies to **O(T log 26)**, which is effectively **O(T)**.

### Overall Time Complexity:
Combining the individual steps:
- **O(T)** for counting task frequencies.
- **O(1)** for building the initial priority queue.
- **O(T)** for processing tasks.

Thus, the total time complexity is **O(T)**, where `T` is the number of tasks in the input vector `tasks`.

### Space Complexity:

1. **Task Frequency Array**:
   - The `map` array holds 26 elements to store the frequency of each task. This is a constant-sized array, so it takes **O(1)** space.

2. **Priority Queue**:
   - The priority queue holds up to 26 elements (one for each possible task type). In the worst case, if all tasks are unique, the priority queue will store 26 tasks.
   - Thus, the space complexity for the priority queue is **O(26)**, which simplifies to **O(1)**.

3. **Temporary Priority Queue (`pqtemp`)**:
   - Similarly, the temporary priority queue `pqtemp` can hold up to `n + 1` tasks at any given time. In the worst case, this is also **O(26)**, which simplifies to **O(1)**.

4. **Count of Intervals**:
   - The variable `countPossibleSequence` is a simple integer and doesn't contribute to space complexity.

### Overall Space Complexity:
Combining the individual space complexities:
- **O(1)** for the task frequency array.
- **O(1)** for the priority queues.
- **O(1)** for temporary variables.

Thus, the total space complexity is **O(1)**, as the space usage is constant and does not depend on the size of the input.

### Conclusion:

- **Time Complexity**: **O(T)**, where `T` is the number of tasks.
- **Space Complexity**: **O(1)**.