

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    class CustomComparator{
        public:
        bool operator()(ListNode* a, ListNode* b){
            return a->val > b->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        //code here
        priority_queue< ListNode*, vector<ListNode*>,
                        CustomComparator > pq;
                        
        for(int i=0; i<lists.size();i++){
            if(lists[i] != NULL)
                pq.push(lists[i]);
        }
        
        ListNode* ans = new ListNode(0);
        ListNode* res = ans;
        while(!pq.empty()){
            ListNode* curr = pq.top();
            pq.pop();

            // if curr null continue
            if(curr == NULL)
                continue;
            
            ans->next = new ListNode(curr->val);
            ans = ans->next;
            
            // delete first element
            ListNode* prev = curr;
            curr = curr->next;
            prev->next = NULL;
            delete prev;
           
           // pushing curr again if not null
            if(curr != NULL)
                pq.push(curr);
        }
        return res->next;
    }
};

Let's analyze the time and space complexity of the provided C++ code for merging `k` sorted linked lists using a **min-heap** (priority queue).

### Code Explanation:

- **Custom Comparator**: A custom comparator is used to create a min-heap. The priority queue will always give us the smallest node value.
- **Priority Queue (Min-Heap)**: The priority queue is initialized and populated with the head of each linked list. It is used to always extract the node with the smallest value across all lists.
- **Merging the Lists**: 
  - The algorithm iterates through the heap, repeatedly extracting the smallest node and adding it to the resulting linked list (`res`).
  - After extracting a node, it checks if the node has a next node. If so, the next node is added to the heap.
  - The list nodes are deleted after being processed to avoid memory leaks.

### Time Complexity:

1. **Inserting elements into the priority queue**:
   - The size of the priority queue will be at most `k` (since we are adding the head of each of the `k` lists). 
   - **Inserting each element into the priority queue** takes **O(log k)** time.
   - Initially, each of the `k` lists' heads is pushed into the priority queue, so this takes **O(k log k)**.

2. **Processing the nodes**:
   - The total number of nodes across all `k` lists is `n` (sum of the lengths of all lists). 
   - In each iteration, we extract the smallest node from the priority queue (which takes **O(log k)**), and we may insert a new node into the heap (also **O(log k)**).
   - Therefore, for each of the `n` nodes, the heap operations (insertion and extraction) take **O(log k)** time.
   - **Time complexity for processing all nodes**: **O(n log k)**.

### Total Time Complexity:
- **O(k log k)** for the initial insertions of the list heads into the priority queue.
- **O(n log k)** for processing all the nodes.

Thus, the overall time complexity is:
- **O(n log k)**, where `n` is the total number of nodes across all the lists and `k` is the number of lists.

### Space Complexity:

1. **Priority Queue**:
   - The priority queue stores at most `k` nodes at any time, one for each list. 
   - Each node is a `ListNode`, and at most `k` nodes are stored in the heap at any time.
   - Therefore, the space complexity for the priority queue is **O(k)**.

2. **New Linked List (Result)**:
   - The result linked list will store all `n` nodes, where `n` is the total number of nodes across all lists.
   - Therefore, the space complexity for the result linked list is **O(n)**.

3. **Auxiliary Space**:
   - Apart from the priority queue and result list, there is no significant additional space being used (the space used by the input list pointers is ignored since we are modifying the existing nodes).

Thus, the total space complexity is:
- **O(k)** for the priority queue.
- **O(n)** for the result linked list.

The total space complexity is:
- **O(n + k)**, where `n` is the total number of nodes and `k` is the number of linked lists.

### Final Conclusion:
- **Time Complexity**: **O(n log k)**, where `n` is the total number of nodes and `k` is the number of lists.
- **Space Complexity**: **O(n + k)**, where `n` is the total number of nodes and `k` is the number of lists.






##############################################################################







To solve this problem, we need to merge `k` sorted linked-lists into one sorted linked-list. We can use a **min-heap** (priority queue) to achieve this efficiently. The min-heap helps to always extract the smallest element among the `k` lists at any given time. 

### Approach:

1. **Use a min-heap** to store the nodes of the linked-lists. Each element of the heap will store a tuple consisting of the value of the node and the index of the list and the node's position within that list. This allows us to always extract the smallest node efficiently.
  
2. **Initialize the heap**: Insert the first node of each of the `k` lists into the heap.

3. **Extract the smallest node** from the heap, and append it to the result linked-list.

4. If the extracted node has a next node, push that next node into the heap.

5. Repeat the process until the heap is empty.

### C++ Code Implementation:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <functional>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
public:
    ListNode* mergeKLists(std::vector<ListNode*>& lists) {
        // Min-heap to store the node and its index
        auto compare = [](ListNode* a, ListNode* b) {
            return a->val > b->val;  // The smaller value comes first
        };
        
        std::priority_queue<ListNode*, std::vector<ListNode*>, decltype(compare)> minHeap(compare);
        
        // Initialize the heap with the first node of each list
        for (ListNode* list : lists) {
            if (list != nullptr) {
                minHeap.push(list);
            }
        }
        
        ListNode* dummy = new ListNode(0);  // Dummy node to simplify the result construction
        ListNode* current = dummy;
        
        // Extract the smallest node and move the pointer
        while (!minHeap.empty()) {
            ListNode* node = minHeap.top();  // Get the smallest node
            minHeap.pop();  // Remove it from the heap
            
            current->next = node;  // Append to the result
            current = current->next;  // Move the pointer to the new last node
            
            if (node->next != nullptr) {
                minHeap.push(node->next);  // Push the next node from the list
            }
        }
        
        return dummy->next;  // Return the merged sorted list
    }
};

// Utility functions to create and print the linked list
ListNode* createList(const std::vector<int>& values) {
    if (values.empty()) return nullptr;
    ListNode* head = new ListNode(values[0]);
    ListNode* current = head;
    for (int i = 1; i < values.size(); ++i) {
        current->next = new ListNode(values[i]);
        current = current->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val;
        if (head->next != nullptr) std::cout << " -> ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // Example 1: Input: [[1,4,5],[1,3,4],[2,6]]
    std::vector<ListNode*> lists;
    lists.push_back(createList({1, 4, 5}));
    lists.push_back(createList({1, 3, 4}));
    lists.push_back(createList({2, 6}));
    
    Solution solution;
    ListNode* mergedList = solution.mergeKLists(lists);
    printList(mergedList);  // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6

    // Example 2: Input: []
    lists.clear();
    mergedList = solution.mergeKLists(lists);
    printList(mergedList);  // Output: (empty)

    // Example 3: Input: [[]]
    lists.push_back(nullptr);
    mergedList = solution.mergeKLists(lists);
    printList(mergedList);  // Output: (empty)

    return 0;
}
```

### Explanation:

1. **ListNode struct**: Represents a node in the linked list with an integer value (`val`) and a pointer to the next node (`next`).
  
2. **mergeKLists function**:
   - We use a priority queue (`minHeap`) to store the current node of each list. The custom comparator ensures that the smallest node (by value) is always at the top of the heap.
   - We initialize the heap by inserting the first node of each list into the heap.
   - Then, we repeatedly extract the smallest node, append it to the result linked-list, and push the next node from the same list (if available) into the heap.
   - A dummy node is used to simplify the linked-list construction, and the result is returned starting from `dummy->next`.

3. **createList function**: Creates a linked list from a vector of integers.

4. **printList function**: Prints the linked list in the format `1 -> 2 -> 3 -> ...`.

### Time Complexity:
- **O(N log k)**, where `N` is the total number of nodes in all lists and `k` is the number of lists. Each insertion and extraction from the heap takes O(log k), and we perform this operation for every node.

### Space Complexity:
- **O(k)**, where `k` is the number of lists. The space is used by the priority queue to store the nodes from each of the `k` lists.

This approach is efficient for the problem constraints.