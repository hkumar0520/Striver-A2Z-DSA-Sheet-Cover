
https://www.geeksforgeeks.org/problems/rearrange-characters4649/1

class Solution
{
    public:
    string rearrangeString(string str)
    {
        //code here
        vector<int> map(256, 0);
        for(char ch: str)
            map[ch]++;

        priority_queue< pair<int,int> > pq;
                        
        for(int i = 0; i<256; i++){
            if(map[i] != 0)
                pq.push({ map[i], i });
        }
            
        string result = "";
        while(!pq.empty())
        {
            pair<int,int> firstElement = pq.top();
            pq.pop();
                
            result = result + (char)(firstElement.second);
            firstElement.first  = firstElement.first-1;
                
            if(!pq.empty()){
                pair<int,int> secondElement = pq.top();
                pq.pop();
                    
                result = result + (char)(secondElement.second);
                secondElement.first = secondElement.first -1;
                    
                if(firstElement.first != 0)
                    pq.push(firstElement);
                        
                if(secondElement.first != 0)
                    pq.push(secondElement);
            }
            else
                break;
        
        }
            
        if(result.size() != str.size() )
            return "-1";
                
        return result;
    }
    
};

Let's analyze the time and space complexity of the given code step by step.

### Code Overview:
The code rearranges the input string such that no two adjacent characters are the same. It does this by:
1. Counting the frequency of each character using an array `map` of size 256 (assuming the input consists of ASCII characters).
2. Using a **max heap (priority queue)** to always pick the character with the highest frequency to place it in the result string.
3. If there are still characters left with non-zero frequency, the algorithm picks the second highest frequency character and places it in the result.
4. It continues this process until it either completes the rearrangement or determines that it's impossible to rearrange the string (if a character's frequency is too high to be placed without violating the adjacent character constraint).

### Time Complexity:

#### 1. **Counting Frequencies (`map` array):**
   - This step iterates over all the characters in the string once, so it takes **O(n)** time, where `n` is the length of the string.

#### 2. **Building the Max Heap:**
   - We are iterating over all possible characters (256 possible characters, assuming ASCII characters), and for each non-zero frequency, we insert it into the max heap.
   - In the worst case, if all 256 characters have a non-zero frequency, this will involve **256 insertions** into the priority queue. The time complexity of inserting an element into a priority queue (or heap) is **O(log k)**, where `k` is the number of elements in the heap.
   - So, the time complexity of this step is **O(256 log 256)**, which is effectively **O(1)** because `256` is constant.

#### 3. **Processing the Priority Queue:**
   - In the `while` loop, the heap is processed, and we pop two elements from the heap in each iteration. The heap operations (pop and push) take **O(log k)** time, where `k` is the number of elements in the heap.
   - In the worst case, there are **n** characters to rearrange, and each character can be processed once. For each character, we may push it back into the heap after decrementing its frequency, so there will be **O(n)** iterations in total. Each heap operation (pop and push) takes **O(log 256)** time, which is **O(1)** because 256 is constant.
   - Hence, this step will take **O(n)** time.

#### 4. **Final Result Check:**
   - Finally, the code checks if the result's size matches the original string's size (`result.size() != str.size()`), which takes **O(n)** time.

### Total Time Complexity:
- Counting character frequencies: **O(n)**
- Building the max heap: **O(1)** (since 256 is a constant)
- Processing the heap: **O(n)**
- Final result check: **O(n)**

Thus, the overall time complexity of the code is **O(n)**.

### Space Complexity:

#### 1. **Space for Frequency Array (`map`):**
   - The `map` array is of size 256 to store the frequency of each character. Hence, the space complexity is **O(256)**, which is **O(1)** because 256 is a constant.

#### 2. **Space for Priority Queue:**
   - In the worst case, the heap will contain all unique characters from the input string. Since there are at most 256 distinct characters in the input (for ASCII), the heap will store at most **256** elements. Therefore, the space complexity for the heap is **O(256)**, which is **O(1)**.

#### 3. **Space for Result String:**
   - The result string will contain the rearranged characters, which will be the same length as the input string. Therefore, the space complexity for the result string is **O(n)**.

### Total Space Complexity:
- The space complexity is dominated by the result string, so the overall space complexity is **O(n)**.

### Summary:

- **Time Complexity:** **O(n)**
- **Space Complexity:** **O(n)**

This is efficient enough for handling large input sizes (up to 100,000 characters as per typical constraints).
