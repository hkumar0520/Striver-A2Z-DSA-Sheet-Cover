

#include <bits/stdc++.h>

class User{
    int userId;
    vector<int> followeed;
    priority_queue<pair<int,int>> tweets;

    public:
    User(){

    }

    User(int userid){
        userId = userid;
        followeed = {};
    }
    // User(const User& oldUser){
    //     userId = oldUser.userId;
    //     followeed = oldUser.followeed;
    //     tweets = oldUser.tweets;
    // }
    // void setUserId(int userId){
    //     userId = userId;
    // }

    void postTweet(int time, int tweetId){
        tweets.push({ time, tweetId });
    }

    priority_queue<pair<int,int>> getTweets(){
        return tweets;
    }

    void followedUser(int followeedId){
        vector<int>::iterator it = find(followeed.begin(), followeed.end(), followeedId);
        if(it == followeed.end()){
            followeed.push_back(followeedId);
        }
    }
    
    void unFollowedUser(int followeedId){
        vector<int>::iterator it = find(followeed.begin(), followeed.end(), followeedId);
        if(it != followeed.end()){
            int index = it-followeed.begin();
            followeed.erase(it);
        }
    }

    vector<int> getFolloweed(){
        return followeed;
    }
};

class Twitter {
    map<int, User> userReference;
    int time = 0;
    
    public:
    Twitter() {
        
    }
    
    void postTweet(int userId, int tweetId) {
        time++;

        User user;
        if(userReference.find(userId) == userReference.end()){
            user = User(userId);
        }
        else{
            user = userReference[userId];
        }

        user.postTweet(time, tweetId);

        // store latest user updates
        userReference.erase(userId);
        userReference[userId] = user;
    }
    
    vector<int> getNewsFeed(int userId) {
        if(userReference.find(userId) == userReference.end())
            return {};

        User user = userReference[userId];

        priority_queue<pair<int,int>> pq = user.getTweets();

        vector<int> followeed = user.getFolloweed();

        for(int iuserid: followeed){
            User usertmp = userReference[iuserid];
            priority_queue<pair<int,int>> pqtmp = usertmp.getTweets();
            while(!pqtmp.empty()){
                pq.push(pqtmp.top());
                pqtmp.pop();
            }
        }

        vector<int> recentTweets;
        int countRecent = 0;

        while(!pq.empty() && countRecent < 10){
            recentTweets.push_back(pq.top().second);
            pq.pop();
            countRecent++;
        }
        return recentTweets;        
    }
    
    void follow(int followerId, int followeeId) {
        User follower;
        if(userReference.find(followerId) == userReference.end()){
            follower = User(followerId); 
        }
        else
            follower = userReference[followerId];

        User followeed;
        if(userReference.find(followeeId) == userReference.end()){
            followeed = User(followeeId); 
            userReference[followeeId] = followeed;
        }

        follower.followedUser(followeeId);

        // store again
        userReference.erase(followerId);
        userReference[followerId] = follower;
    }
    
    void unfollow(int followerId, int followeeId) {
        if(userReference.find(followerId) == userReference.end())
            return ;
        if(userReference.find(followeeId) == userReference.end())
            return ;

        User follower = userReference[followerId];

        follower.unFollowedUser(followeeId);
        
        // store again
        userReference.erase(followerId);
        userReference[followerId] = follower;
    }
};

/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter* obj = new Twitter();
 * obj->postTweet(userId,tweetId);
 * vector<int> param_2 = obj->getNewsFeed(userId);
 * obj->follow(followerId,followeeId);
 * obj->unfollow(followerId,followeeId);
 */

 
 #########################################################################



To reduce the memory usage in the provided code, there are several strategies we can adopt, such as avoiding unnecessary object copies, reusing memory, and reducing redundant data structures. Below are some changes to reduce memory consumption:

### Key Changes:
1. **Avoid unnecessary copying of objects:**
   - Instead of copying entire `User` objects, we can pass references to the `User` class objects wherever possible to avoid the overhead of copying large objects.
   
2. **Use pointers in place of copying objects:**
   - By using pointers to `User` objects, we avoid the need to copy objects when updating the `userReference` map or performing operations like following and unfollowing users.
   
3. **Reduce `priority_queue` usage:**
   - `priority_queue` may consume more memory than necessary, as it internally uses a heap and requires memory for the heap structure. A better approach might be to store the tweets in a sorted list or vector and limit its size.

4. **Optimize user-followed list:**
   - Use `unordered_set` or `set` for `followeed` to optimize the lookup time and memory usage when checking if a user is already followed.

5. **Avoid storing redundant `priority_queue` copies:**
   - Instead of copying the entire `priority_queue`, we can merge the queues more efficiently or store tweets in a simpler structure.

### Optimized Code:

```cpp
#include <bits/stdc++.h>

using namespace std;

class User {
public:
    int userId;
    unordered_set<int> followeed;
    deque<pair<int, int>> tweets;  // Using deque to store tweets in reverse order for easy push_back and pop_front.

    User(int userid) : userId(userid) {}

    // Post a new tweet with a timestamp.
    void postTweet(int time, int tweetId) {
        tweets.push_front({time, tweetId}); // Store tweets in reverse order to keep the most recent ones at the front
        if (tweets.size() > 10) { // We only need the 10 most recent tweets
            tweets.pop_back();
        }
    }

    // Add a user to the following list.
    void followedUser(int followeedId) {
        followeed.insert(followeedId);
    }

    // Remove a user from the following list.
    void unFollowedUser(int followeedId) {
        followeed.erase(followeedId);
    }
};

class Twitter {
    unordered_map<int, User*> userReference;  // Use pointers to avoid copying entire User objects
    int time = 0;
    
public:
    Twitter() {}

    // Post a new tweet
    void postTweet(int userId, int tweetId) {
        time++;
        
        if (userReference.find(userId) == userReference.end()) {
            userReference[userId] = new User(userId);
        }
        
        User* user = userReference[userId];
        user->postTweet(time, tweetId);
    }
    
    // Get the news feed of a user
    vector<int> getNewsFeed(int userId) {
        if (userReference.find(userId) == userReference.end()) {
            return {};
        }

        User* user = userReference[userId];
        vector<pair<int, int>> allTweets;
        
        // Add the tweets of the user
        for (auto& tweet : user->tweets) {
            allTweets.push_back(tweet);
        }

        // Add the tweets of the users they follow
        for (int followeeId : user->followeed) {
            if (userReference.find(followeeId) != userReference.end()) {
                User* followee = userReference[followeeId];
                for (auto& tweet : followee->tweets) {
                    allTweets.push_back(tweet);
                }
            }
        }

        // Sort tweets by timestamp in descending order and return the 10 most recent tweets
        sort(allTweets.begin(), allTweets.end(), greater<pair<int, int>>());

        vector<int> recentTweets;
        for (int i = 0; i < min(10, (int)allTweets.size()); i++) {
            recentTweets.push_back(allTweets[i].second);
        }

        return recentTweets;
    }
    
    // Follow a user
    void follow(int followerId, int followeeId) {
        if (userReference.find(followerId) == userReference.end()) {
            userReference[followerId] = new User(followerId);
        }
        
        if (userReference.find(followeeId) == userReference.end()) {
            userReference[followeeId] = new User(followeeId);
        }
        
        User* follower = userReference[followerId];
        follower->followedUser(followeeId);
    }
    
    // Unfollow a user
    void unfollow(int followerId, int followeeId) {
        if (userReference.find(followerId) == userReference.end()) return;
        if (userReference.find(followeeId) == userReference.end()) return;

        User* follower = userReference[followerId];
        follower->unFollowedUser(followeeId);
    }
};

```

### Optimizations Breakdown:
1. **Pointer-based storage:**
   - Instead of copying `User` objects every time, the `userReference` map now stores pointers to `User` objects. This avoids unnecessary deep copies of `User` objects.

2. **Efficient tweet storage:**
   - A `deque` is used to store tweets, which allows efficient push and pop operations at both ends. We only keep the 10 most recent tweets, reducing memory usage. Once there are more than 10 tweets, the oldest is discarded.

3. **Using `unordered_set` for following users:**
   - The `followeed` list is now an `unordered_set`, which provides faster lookups and reduces the space complexity of following checks.

4. **Efficient news feed generation:**
   - The tweets are directly stored in a vector (`allTweets`), which is then sorted by time, and only the top 10 tweets are selected, which avoids maintaining a large priority queue.

5. **Avoiding redundant object creation:**
   - Users are created only once and reused through the pointer mechanism. The code doesn't recreate user objects unnecessarily.

This should reduce memory usage, as it avoids storing redundant copies of user data, tweets, and reduces the overhead of priority queues.


Let's analyze the **time complexity** and **space complexity** of the given code.

### Time Complexity:

#### 1. **`postTweet(int userId, int tweetId)`**:

- **Checking if the user exists**:  
  `userReference.find(userId)` takes O(1) time on average due to the unordered_map structure.
  
- **Creating a new user if not present**:  
  If the user does not exist, a new `User` object is created. This is a constant-time operation, O(1).
  
- **Posting a tweet**:  
  The `postTweet()` function inside the `User` class performs the following operations:
  - `tweets.push_front()` takes O(1) time.
  - If the number of tweets exceeds 10, `tweets.pop_back()` is performed, which is O(1).
  
  So, the time complexity of `postTweet()` is O(1).

Thus, the overall time complexity for `postTweet(int userId, int tweetId)` is **O(1)**.

#### 2. **`getNewsFeed(int userId)`**:

- **Checking if the user exists**:  
  `userReference.find(userId)` takes O(1) time.
  
- **Gathering the user's tweets**:  
  For the user, you iterate through their `tweets` (at most 10 tweets), which takes O(10) = O(1) time.

- **Gathering tweets of followed users**:  
  You loop over all the users the given user is following (`user->followeed`). For each followed user, you add their tweets (again, at most 10 tweets per user). 
  If there are `m` users being followed, the total time to gather all the tweets is O(m * 10) = O(m), where `m` is the number of users the given user is following.

- **Sorting all the collected tweets**:  
  The total number of tweets collected will be at most `(10 + 10 * m)`. Sorting these tweets will take O((10 + 10 * m) log(10 + 10 * m)) time. Since we are interested only in the top 10 tweets, the complexity can be simplified to O(m log m).

Thus, the overall time complexity for `getNewsFeed(int userId)` is **O(m log m)**, where `m` is the number of users the given user is following.

#### 3. **`follow(int followerId, int followeeId)`**:

- **Checking if the users exist**:  
  `userReference.find(followerId)` and `userReference.find(followeeId)` each take O(1) time.
  
- **Adding the followee to the follower's follow list**:  
  `follower->followedUser(followeeId)` calls `insert()` on an `unordered_set`, which takes O(1) time on average.
  
Thus, the overall time complexity for `follow(int followerId, int followeeId)` is **O(1)**.

#### 4. **`unfollow(int followerId, int followeeId)`**:

- **Checking if the users exist**:  
  `userReference.find(followerId)` and `userReference.find(followeeId)` each take O(1) time.

- **Removing the followee from the follower's follow list**:  
  `follower->unFollowedUser(followeeId)` calls `erase()` on an `unordered_set`, which takes O(1) time on average.

Thus, the overall time complexity for `unfollow(int followerId, int followeeId)` is **O(1)**.

### Space Complexity:

- **`userReference` unordered_map**:  
  This stores a `User*` for each unique `userId`. If there are `n` unique users, the space complexity for this map is O(n).
  
- **`User` objects**:  
  Each `User` object has:
  - `userId`: an integer (O(1) space).
  - `followeed`: an unordered set, which can contain up to `n` users in the worst case, so space complexity for this is O(n).
  - `tweets`: a deque that stores up to 10 tweets for each user, which is O(10) = O(1).

  So, the total space used by all `User` objects is O(n) for `userId` and `followeed`, and O(n) for the `userReference` map.

- **Additional space for `getNewsFeed`**:  
  The `getNewsFeed` function creates a temporary vector `allTweets` to store tweets from the user and their followees. In the worst case, this could store `(1 + m) * 10` tweets, where `m` is the number of users the user is following, leading to a space complexity of O(m * 10) = O(m).

Thus, the overall space complexity is **O(n + m)**, where:
- `n` is the number of unique users,
- `m` is the number of users a given user follows.

### Final Complexity Summary:

- **Time Complexity**:
  - `postTweet(int userId, int tweetId)`: O(1)
  - `getNewsFeed(int userId)`: O(m log m)
  - `follow(int followerId, int followeeId)`: O(1)
  - `unfollow(int followerId, int followeeId)`: O(1)

- **Space Complexity**: O(n + m)



