

class Solution {
  public:
    int totalFruits(vector<int> &arr) {
        // code here
        int maxLen = 0, n = arr.size();
        
        for(int i = 0; i<n; i++){
            set<int> st;
            for(int j=i; j<n; j++){
                st.insert(arr[j]);
                
                if(st.size() <= 2)
                    maxLen = max(maxLen, j-i+1);
                else
                    break;
            }
        }
        return maxLen;
    }
};


time complexity - O(n*n)
space complexity - O(1)


####################################################################


class Solution {
  public:
    int totalFruits(vector<int> &arr) {
        // code here
        int maxLen = 0, n = arr.size();
        int l = 0, r = 0;
        map<int,int> mp;
        
        
        while(r<n){
            mp[arr[r]]++;
            
            while(mp.size() > 2){
                mp[arr[l]]--;
                if(mp[arr[l]] == 0)
                    mp.erase(arr[l]);
                
                l++;
            }
            
            if(mp.size() <= 2)
                maxLen = max(maxLen, r-l+1);
            
            r++;
        }
        return maxLen;
    }
};

Time complexity - O(2*n)
Space Complexity - O(1)

#####################################################################


class Solution {
  public:
    int totalFruits(vector<int> &arr) {
        // code here
        int maxLen = 0, n = arr.size();
        int l = 0, r = 0;
        map<int,int> mp;
        
        
        while(r<n){
            mp[arr[r]]++;
            
            if(mp.size() > 2){
                mp[arr[l]]--;
                if(mp[arr[l]] == 0)
                    mp.erase(arr[l]);
                
                l++;
            }
            
            if(mp.size() <= 2)
                maxLen = max(maxLen, r-l+1);
            
            r++;
        }
        return maxLen;
    }
};

Time complexity - O(n)
Space Complexity - O(1)


####################################################################

This problem can be efficiently solved using the **sliding window technique**. The idea is to maintain a window of valid fruits that contains at most two distinct types of fruits. The steps are:

1. Use two baskets to store the types of fruits.
2. Expand the window by adding fruits from the right while ensuring the window contains at most two distinct fruit types.
3. If the window contains more than two distinct fruit types, shrink it from the left until it becomes valid.
4. Track the maximum size of the valid window during this process.

---

### Optimal Solution in C++:

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int totalFruit(vector<int>& arr) {
        unordered_map<int, int> fruitCount; // To store the count of each fruit in the window
        int left = 0; // Left pointer of the sliding window
        int maxFruits = 0; // Maximum fruits collected

        for (int right = 0; right < arr.size(); ++right) {
            fruitCount[arr[right]]++; // Add the current fruit to the basket

            // If we have more than 2 types of fruits, shrink the window
            while (fruitCount.size() > 2) {
                fruitCount[arr[left]]--; // Remove the leftmost fruit
                if (fruitCount[arr[left]] == 0) {
                    fruitCount.erase(arr[left]); // Remove the fruit type completely if count is zero
                }
                left++; // Move the left pointer
            }

            // Update the maximum fruits collected
            maxFruits = max(maxFruits, right - left + 1);
        }

        return maxFruits;
    }
};

int main() {
    Solution sol;

    vector<int> arr1 = {2, 1, 2};
    cout << sol.totalFruit(arr1) << endl; // Output: 3

    vector<int> arr2 = {3, 1, 2, 2, 2, 2};
    cout << sol.totalFruit(arr2) << endl; // Output: 5

    vector<int> arr3 = {1, 2, 3, 2, 2};
    cout << sol.totalFruit(arr3) << endl; // Output: 4

    return 0;
}
```

---

### Explanation:

1. **Sliding Window**:
   - The `left` and `right` pointers define the current window of fruits being considered.
   - The `fruitCount` map keeps track of the count of each fruit type in the current window.

2. **Expand Window**:
   - Add the current fruit to the window by incrementing its count in `fruitCount`.

3. **Shrink Window**:
   - If the window contains more than two distinct fruit types, increment the `left` pointer to shrink the window and remove fruits from `fruitCount` as necessary.

4. **Track Maximum**:
   - After ensuring the window is valid, calculate the size of the current window and update `maxFruits`.

---

### Complexity:

- **Time Complexity**: \(O(n)\)
  - Each element is processed at most twice (once when expanding the window and once when shrinking it).
- **Space Complexity**: \(O(1)\)
  - The `fruitCount` map contains at most 2 keys at any time, so the space complexity is constant.

This solution is optimal and works efficiently even for the maximum constraint of \(10^5\) elements.