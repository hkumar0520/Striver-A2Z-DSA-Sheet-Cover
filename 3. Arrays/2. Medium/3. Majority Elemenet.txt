
1. Brute force
2. hashing
3. two pointers



class Solution {
    public int majorityElement(int[] nums) {
        for(int i = 0; i<nums.length; i++){
            int number = nums[i], cnt = 0;

            for(int num: nums){
                if(number == num)
                    cnt++;
            }
            if(cnt > nums.length/2)
                return number;
        }
        return -1;
    }
}

TC: O(n*n)
SC: O(1)

#######################################################################


class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int num: nums){
            map.put(num, map.getOrDefault(num,0) + 1);
        }

        for(Map.Entry<Integer, Integer> entry: map.entrySet()){
            if(entry.getValue() > nums.length/2)
                return  entry.getKey();
        }
        return -1;
    }
}

TC: O(nlogn)
SC: O(n)







#######################################################################

class Solution {
    public int majorityElement(int[] nums) {
        int countt = 0, number = -1;
        for(int num: nums){
            if(countt == 0){
                number = num;
                countt = 1;
            }
            else if(num == number)
                countt++;
            else
                countt--;
        }

        //  verify
        int countNum = 0;
        for(int num: nums){
            if(num == number)
                countNum++;
        }

        if(countNum > nums.length/2)
            return number;

        return -1;
        
    }
}

TC: O(n)
SC: O(1)


