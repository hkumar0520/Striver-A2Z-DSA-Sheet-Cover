

1. Brute  forcee
2. Optimal


class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());

        vector<vector<int>> ans;

        for(int i =0; i<intervals.size(); i++){
            int start = intervals[i][0], endd = intervals[i][1];

            if(!ans.empty() && endd <= ans.back()[1])
                continue;

            for(int j = i+1; j<intervals.size(); j++){
                if( endd >= intervals[j][0])
                    endd = max(endd, intervals[j][1]);
                else
                    break;
            }
            ans.push_back({ start, endd});
        }
        return ans;
    }
};

TC: O( nlogn) + O(2n)
SC: O(1)


###########################################################################



class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());

        vector<vector<int>> ans;

        for(int i =0; i<intervals.size(); i++){
            int start = intervals[i][0], endd = intervals[i][1];

            if( ans.empty() || start > ans.back()[1])
                ans.push_back({ start, endd});
            else
                ans.back()[1] = max( ans.back()[1], endd);
        }
        return ans;
    }
};


TC: O(nlogn) + O(n)
SC: O(1)


















