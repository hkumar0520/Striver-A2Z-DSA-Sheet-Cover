

1. Brute force
2. better (O(n*n, 1))
3. using logic
4. using kadance algo



better

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int maxProd = INT_MIN, n = nums.size();
        for(int i = 0; i<n; i++){
            int prod = 1;
            for(int j = i; j<n; j++){
                prod = prod * nums[j];

                maxProd = max(maxProd, prod);
            }
        }
        return maxProd;
    }
};

TC: O(n*n)
SC: O(1)


###################################################################


class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int prefix = 1, suffix = 1, numsLen = nums.size(), maxProd = INT_MIN;

        for(int i = 0; i<numsLen; i++){
            if(prefix == 0) prefix = 1;
            if(suffix == 0) suffix = 1;

            prefix *= nums[i];
            suffix *= nums[numsLen-1-i];

            maxProd = max({ maxProd, prefix, suffix});
        }
        return maxProd;
    }
};


TC: O(n)
SC: O(1)


#######################################################################


int maxProductSubArray(vector<int>& nums) {
    int prod1 = nums[0],prod2 = nums[0],result = nums[0];
    
    for(int i=1;i<nums.size();i++) {
        int temp = max({nums[i],prod1*nums[i],prod2*nums[i]});
        prod2 = min({nums[i],prod1*nums[i],prod2*nums[i]});
        prod1 = temp;
        
        result = max(result,prod1);
    }
    
    return result;
}

TC: O(n)
SC: O(1)





























