


1. Brute force (n*n*n)
2. Better (n*n)
3. Optimal (nlog(n))


class Solution {
  public:
    // Function to count inversions in the array.
        void merge(vector<int>& nums, int low, int mid, int  high, int& cnt){

        int l = mid+1;
        for(int k = low; k<=mid; k++){
            while(l<=high && nums[k] > nums[l])
                l++;
            cnt += (l - (mid+1));
        }


        int i = low, j = mid+1;

        vector<int> arr;
        while( i<=mid && j<= high){
            if(nums[i] <= nums[j]){
                arr.push_back(nums[i]);
                i++;
            }
            else{
                arr.push_back(nums[j]);
                j++;
            }
        }

        while(i <= mid)
            arr.push_back(nums[i++]);

        while(j <= high)
            arr.push_back(nums[j++]);

        for(int k = low; k<=high; k++)
            nums[k] = arr[k-low];
    }
    void mergeSort(vector<int>& nums, int low , int high, int& cnt){
        if(low >= high) return ;
        
        int mid = (low + high)/2;
        mergeSort(nums, low, mid, cnt);
        mergeSort(nums, mid+1, high, cnt);
        merge(nums, low , mid , high, cnt);
        return ;
    }
 
    
    int inversionCount(vector<int> &nums) {
        // Your Code Here
        int cnt = 0;
        mergeSort(nums, 0, nums.size()-1, cnt);
        return cnt;
    }
};

TC: nlogn
SC: O(1)



######################################################################

class Solution {
  public:
    // Function to count inversions in the array.
        void merge(vector<int>& nums, int low, int mid, int  high, int& cnt){

        // int l = mid+1;
        // for(int k = low; k<=mid; k++){
        //     while(l<=high && nums[k] > nums[l])
        //         l++;
        //     cnt += (l - (mid+1));
        // }


        int i = low, j = mid+1;

        vector<int> arr;
        while( i<=mid && j<= high){
            if(nums[i] <= nums[j]){
                arr.push_back(nums[i]);
                i++;
            }
            else{
                cnt += (mid - i  + 1);
                arr.push_back(nums[j]);
                j++;
            }
        }

        while(i <= mid)
            arr.push_back(nums[i++]);

        while(j <= high)
            arr.push_back(nums[j++]);

        for(int k = low; k<=high; k++)
            nums[k] = arr[k-low];
    }
    void mergeSort(vector<int>& nums, int low , int high, int& cnt){
        if(low >= high) return ;
        
        int mid = (low + high)/2;
        mergeSort(nums, low, mid, cnt);
        mergeSort(nums, mid+1, high, cnt);
        merge(nums, low , mid , high, cnt);
        return ;
    }
 
    
    int inversionCount(vector<int> &nums) {
        // Your Code Here
        int cnt = 0;
        mergeSort(nums, 0, nums.size()-1, cnt);
        return cnt;
    }
};



