

1. Brute force
2. Single Pass


// brute force

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        
        int maxOnes = 0, len = nums.size();
        for(int i = 0; i<len; i++)
        {
            for(int j = i ; j<len; j++){
                if(nums[j] == 0)    break;

                maxOnes = max(maxOnes, j-i+1);
            }
        }
        return maxOnes;
    }
};

TC: O(n*n)
SC: O(1)


##########################################################################################



class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        
        int maxOnes = 0, len = nums.size();
        int left = 0, right = 0;
        while(right < len){

            while(right < len && nums[right] == 0){
                right++;
                left = right;
            }

            if(right < len && nums[right] == 1)
                maxOnes = max(maxOnes, right - left + 1);

            right++;
        }
        return maxOnes;
    }
};

TC: O(n)
SC: O(1)


#########################################################################################

// simple for loop

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int maxCnt = 0, cnt = 0;
        for(int num: nums){
            if( num == 0)
                cnt = 0;
            else
                cnt++;

            maxCnt = max( maxCnt, cnt);
        }
        return maxCnt;
    }
};

TC: O(n)
SC: O(1)




