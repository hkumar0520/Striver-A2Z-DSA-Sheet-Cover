

struct Node{
    Node* links[26];
    bool flag = false;

    bool isContainsKey(char ch){
        return links[ch-'A'] != NULL;
    }
    
    Node* get(char ch)
    {
        return links[ch-'A'];
    }

    void put(char ch,Node* node)
    {
        links[ch-'A'] = node;
    }

    bool getEnd(){
        return flag;
    }

    void setEnd(){
        flag = true;
    }
    
};

class Trie{
    Node* root;
    
    public:
    Trie(){
        root = new Node();
    }
    
    void Insert(string word){
        Node* curr = root;
        
        for(int i=0; i<word.size(); i++){
            if(word[i] >= 'A' && word[i]<= 'Z'){
                if( !curr->isContainsKey(word[i]))
                    curr->put(word[i], new Node());
                    
                curr = curr->get(word[i]);
            }
        }
        curr->setEnd();
    }
    
    bool Check(string word){
        Node* curr = root;
        
        for(int i=0; i<word.size(); i++){
            if(word[i] >= 'A' && word[i]<= 'Z'){
                if( !curr->isContainsKey(word[i]))
                    return false;
                
                curr = curr->get(word[i]);
                
                if(curr->getEnd())  return true;
            }
        }
        return curr->getEnd();
    }
};

class Solution {
  public:
    vector<string> camelCase(vector<string> &arr, string &pat) {
        // code here
        
        Trie* trie = new Trie();
        trie->Insert(pat);
        
        vector<string> ans;
        
        for(int i=0; i<arr.size(); i++){
            if( trie->Check(arr[i]))
                ans.push_back(arr[i]);
        }
        return ans;
    }
};












### Time and Space Complexity Analysis:

#### **1. `Insert` method complexity**:

```cpp
void Insert(string word) {
    Node* curr = root;
    for (int i = 0; i < word.size(); i++) {
        if (word[i] >= 'A' && word[i] <= 'Z') {
            if (!curr->isContainsKey(word[i]))
                curr->put(word[i], new Node());

            curr = curr->get(word[i]);
        }
    }
    curr->setEnd();
}
```

- **Time Complexity**: The `Insert` method involves iterating over each character of the input word (length of the word is `m`). For each character, the `isContainsKey` and `get` methods take constant time, as they only involve an index-based lookup (constant time access in the array of size 26). Thus, the overall time complexity for inserting a single word is **O(m)**, where `m` is the length of the word.
  
- **Space Complexity**: The space complexity for this method is **O(m)**, where `m` is the length of the word being inserted. Each new character of the word may potentially create a new `Node` in the Trie, and each node uses space for an array of size 26 (for each letter of the alphabet). Therefore, the space complexity is proportional to the length of the word inserted, since at most `m` nodes might be created.

#### **2. `Check` method complexity**:

```cpp
bool Check(string word) {
    Node* curr = root;
    for (int i = 0; i < word.size(); i++) {
        if (word[i] >= 'A' && word[i] <= 'Z') {
            if (!curr->isContainsKey(word[i]))
                return false;

            curr = curr->get(word[i]);

            if (curr->getEnd()) return true;
        }
    }
    return curr->getEnd();
}
```

- **Time Complexity**: The `Check` method involves iterating over each character of the word (length `m`). For each character, we perform constant time operations (`isContainsKey`, `get`, `getEnd`). In the worst case, we might have to check the entire word, so the time complexity is **O(m)**, where `m` is the length of the word being checked.

- **Space Complexity**: The space complexity of this method is **O(1)**, because no additional space (like new nodes) is allocated for checking a word; only a few variables (`curr` and `i`) are used.

#### **3. `camelCase` method complexity**:

```cpp
vector<string> camelCase(vector<string>& arr, string& pat) {
    Trie* trie = new Trie();
    trie->Insert(pat);

    vector<string> ans;

    for (int i = 0; i < arr.size(); i++) {
        if (trie->Check(arr[i]))
            ans.push_back(arr[i]);
    }
    return ans;
}
```

- **Time Complexity**: 

  - In this method, we first insert the pattern `pat` into the Trie, which takes **O(m)**, where `m` is the length of `pat`.
  - Then, we iterate through each string in the `arr` (say `n` strings), and for each string, we call `Check` on it. For each string `arr[i]`, `Check` takes **O(k)** time, where `k` is the length of the string being checked.
  - Therefore, the overall time complexity for this method is **O(m + n * k)**, where `n` is the number of strings in the array `arr`, `m` is the length of the pattern `pat`, and `k` is the average length of strings in `arr`.

- **Space Complexity**:
  - The Trie itself requires space for the nodes it stores. In the worst case, if every word in `arr` is inserted, it will use space proportional to the total number of characters in all the words inserted. Since `pat` is the only word inserted in the `Insert` method, the space complexity of the Trie is **O(m)** for storing the `pat`.
  - The space for the result vector `ans` is proportional to the number of strings in `arr` that match the pattern. In the worst case, where all strings match, the space complexity for the answer vector is **O(n)**.

### **Overall Complexity Summary**:

#### **Time Complexity**:
- **Insert**: O(m) for a single word (where `m` is the length of the word)
- **Check**: O(m) for a single word (where `m` is the length of the word)
- **camelCase**: O(m + n * k) where `m` is the length of the pattern, `n` is the number of words in the input array, and `k` is the average length of the words in the array.

#### **Space Complexity**:
- **Insert**: O(m) for a single word insertion (due to the Trie nodes).
- **Check**: O(1) (no additional space used apart from a few pointers).
- **camelCase**: O(m) for the Trie storing the pattern and O(n) for the result vector containing matched words.

