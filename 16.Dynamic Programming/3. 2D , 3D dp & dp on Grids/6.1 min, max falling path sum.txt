
https://leetcode.com/problems/minimum-falling-path-sum-ii/

variable point to variable point 


1. memoization 
2. tabulation 
3. optimization

class Solution {
public:
    int f(int i, int j, int sideLen, vector<vector<int>>& grid, vector<vector<int>>& dp){
        // no need of below line 
        // if(j<0 || j>=sideLen) return 1e9;

        if(i == 0)  return dp[i][j] = grid[i][j];

        if(dp[i][j] != -1e5)    return dp[i][j];

        int minAns = 1e9;
        for(int k = 0; k<sideLen; k++){
            if(k == j)  continue;
            int pathSum = grid[i][j] + f(i-1, k, sideLen, grid, dp);
            minAns = min( minAns, pathSum);
        }

        return dp[i][j] = minAns;
    }
    int minFallingPathSum(vector<vector<int>>& grid) {
        int  n = grid.size();
        if(n == 1)
            return grid[0][0];

        vector<vector<int>> dp(n, vector<int>(n, -1e5));

        int minAns = 1e9;
        for(int j = 0; j<n; j++){
            for(int k = 0; k<n; k++){
                if(j == k)  continue;
                int pathSum = grid[n-1][j] + f(n-2, k, n, grid, dp);
                minAns = min( minAns, pathSum);
            }
            dp[n-1][j] = minAns;
        }
        return minAns;
    }
};


TC: O(n*n*n)
SC: O(n*n) + n{
    dp = n*n 
    stack space = n
}


##########################################################################################


1. recursion 1

// new approach recursion 

class Solution {
public:
    int f(int i, int col, int sideLen, vector<vector<int>>& grid){
        if(i == -1)  return 0;
        int minAns = 1e9;
        for(int k = 0; k<sideLen; k++){
            if(k == col)  continue;
            int pathSum = grid[i][k] + f(i-1, k, sideLen, grid);
            minAns = min( minAns, pathSum);
        }

        return minAns;
    }
    int minFallingPathSum(vector<vector<int>>& grid) {
        int  n = grid.size();
        if(n == 1)
            return grid[0][0];
            
        int minAns = 1e9;
        for(int j = 0; j<n; j++){
            int pathSum = grid[n-1][j] + f(n-2, j, n, grid);
            minAns = min( minAns, pathSum);
        }
        return minAns;
    }
};

######################################################################################


2. recrusion 2

class Solution {
public:
    int f(int i, int col, int sideLen, vector<vector<int>>& grid){
        
        int minAns = 1e9;
        for(int k = 0; k<sideLen; k++){
            if(k == col)  continue;
            int pathSum = grid[i][k];
            if(i > 0)
                pathSum += f(i-1, k, sideLen, grid);

            minAns = min( minAns, pathSum);
        }

        return minAns;
    }
    int minFallingPathSum(vector<vector<int>>& grid) {
        int  n = grid.size();
        if(n == 1)
            return grid[0][0];
            
        int minAns = 1e9;
        for(int j = 0; j<n; j++){
            int pathSum = grid[n-1][j] + f(n-2, j, n, grid);
            minAns = min( minAns, pathSum);
        }
        return minAns;
    }
};


##################################################################################


3. recusion3


class Solution {
public:
    int f(int i, int col, int sideLen, vector<vector<int>>& grid){
        
        if(i == 0){
            int minAns = 1e9;
            for(int k = 0; k<sideLen; k++){
                if(k == col)  continue;
                int pathSum = grid[i][k];

                minAns = min( minAns, pathSum);
            }
            return minAns;
        }

        int minAns = 1e9;
        for(int k = 0; k<sideLen; k++){
            if(k == col)  continue;
            int pathSum = grid[i][k] + f(i-1, k, sideLen, grid);

            minAns = min( minAns, pathSum);
        }

        return minAns;
    }
    int minFallingPathSum(vector<vector<int>>& grid) {
        int  n = grid.size();
        if(n == 1)
            return grid[0][0];
            
        int minAns = 1e9;
        for(int j = 0; j<n; j++){
            int pathSum = grid[n-1][j] + f(n-2, j, n, grid);
            minAns = min( minAns, pathSum);
        }
        return minAns;
    }
};


################################################################################

class Solution {
public:
    int f(int i, int col, int sideLen, vector<vector<int>>& grid, vector<vector<int>>& dp){
        
        if(i == 0){
            int minAns = 1e9;
            for(int k = 0; k<sideLen; k++){
                if(k == col)  continue;
                int pathSum = grid[i][k];

                minAns = min( minAns, pathSum);
            }
            return minAns;
        }
        
        if(dp[i][col] != 1e5)   return dp[i][col];

        int minAns = 1e9;
        for(int k = 0; k<sideLen; k++){
            if(k == col)  continue;
            int pathSum = grid[i][k] + f(i-1, k, sideLen, grid, dp);

            minAns = min( minAns, pathSum);
        }

        return dp[i][col] = minAns;
    }
    int minFallingPathSum(vector<vector<int>>& grid) {
        int  n = grid.size();
        if(n == 1)
            return grid[0][0];
            
        int minAns = 1e9;
        vector<vector<int>> dp(n, vector<int>(n, 1e5));
        for(int j = 0; j<n; j++){
            int pathSum = grid[n-1][j] + f(n-2, j, n, grid, dp);
            minAns = min( minAns, pathSum);
        }
        return minAns;
    }
};



TC: O(n*n)
SC: O(n*n) + n{
    dp = n*n 
    stack space = n
}

