

1. recursion 
2. memoization
3. tabulation
4. optimization

// recursion

#include <bits/stdc++.h> 
int f(int m,int n)
{
	if(m==0 && n==0)	return 1;
	if(m<0 || n<0) 	return 0;

	return f(m-1,n) + f(m,n-1);
}
int uniquePaths(int m, int n) {
	// Write your code here.
	return f(m-1,n-1);
}

TC: 2^(m*n)
SC: O(m-1 + n-1){
	stack space = m-1 + n-1
}


###############################################################################################

// memoization, time limit exceed, 26/80
#include <bits/stdc++.h> 
int f(int m,int n, vector<vector<int>> dp)
{
	if(m==0 && n==0)	return 1;
	if(m<0 || n<0) 	return 0;

	if(dp[m][n]!=-1)
		return dp[m][n];

	return dp[m][n] = f(m-1,n,dp) + f(m,n-1,dp);
}
int uniquePaths(int m, int n) {
	// Write your code here.
	vector<vector<int>> dp(m,vector<int>(n,-1));
	return f(m-1,n-1, dp);
}

TC: O(m*n)
SC: O(m*n) + O(m-1 + n-1){
	stack space = m-1 + n-1
	dp = m*n 
}


###############################################################################################

// tabular approach
#include <bits/stdc++.h> 
int f(int m,int n, vector<vector<int>> dp)
{
	for(int i=0;i<=m;i++)
	{
		for(int j=0;j<=n;j++)
		{
			if(i==0 && j==0)
			{
				dp[i][j] = 1;
				continue;
			}
			
			int up = 0, left = 0;
			if(i>0)
				up = dp[i-1][j];
			
			if(j>0)
				left = dp[i][j-1];

			dp[i][j] = up+left;
		}
	}
	return dp[m][n];
}
int uniquePaths(int m, int n) {
	// Write your code here.
	vector<vector<int>> dp(m,vector<int>(n,-1));
	return f(m-1,n-1, dp);
}

TC: O(m*n)
SC: O(m*n)

###############################################################################################

class Solution {
public:
    int f(int m,int n, vector<int>& dp)
    {
        for(int i=1;i<=m;i++)
        {
            vector<int> prev = dp;
            for(int j=1;j<=n;j++)
            {
                int up = prev[j];
                int left = dp[j-1];

                dp[j] = up+left;
            }
        }
        return dp[n];
    }
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        return f(m-1,n-1, dp);
    }
};

TC: O(m*n)
SC: O(2*n)


###############################################################################################


// optimized
#include <bits/stdc++.h> 
int uniquePaths(int m, int n) {
	// Write your code here.
	vector<int> dp(n,1);
	for(int i=1;i<m;i++)
	{
		for(int j=1;j<n;j++)
		{
			dp[j] += dp[j-1];
		}
	}
	return dp[n-1];
}

TC: O(m*n)
SC: O(n)

