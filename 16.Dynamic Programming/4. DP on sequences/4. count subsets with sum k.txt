
// recursion

int f(int ind, int target, vector<int> &arr)
{
    if(target == 0) return 1;
    if (ind == 0) 
      return (arr[ind] == target) ? 1 : 0;
   

    int nonPick = f(ind-1, target,arr);
    int pick = 0;
    if(arr[ind]<=target)
        pick = f(ind-1, target-arr[ind], arr);

    return pick + nonPick;
}


int findWays(vector<int>& arr, int k)
{
	// Write your code here.
	int  n = arr.size();
	return f(n-1, k, arr);
}


###############################################################################################


// memoization

int f(int ind, int target, vector<int> &arr, vector<vector<int>> &dp)
{
    if(target == 0) return 1;
    if (ind == 0) 
      return (arr[ind] == target) ? 1 : 0;

	if(dp[ind][target] != -1)	return dp[ind][target];
   

    int nonPick = f(ind-1, target,arr,dp);
    int pick = 0;
    if(arr[ind]<=target)
        pick = f(ind-1, target-arr[ind], arr,dp);

    return dp[ind][target] = pick + nonPick;
}


int findWays(vector<int>& arr, int k)
{
	// Write your code here.
	int  n = arr.size();
	vector<vector<int>> dp(n,vector<int>(k+1,-1));
	return f(n-1, k, arr, dp);
}

###############################################################################################

// tabular approach 

int f(int n, int target, vector<int> &arr, vector<vector<int>> &dp)
{

	for(int i=0;i<n;i++)
		dp[i][0] = 1;
	
	if(arr[0]<=target)
		dp[0][arr[0]] = 1;

    for(int i=1;i<n;i++)
	{
		for(int j=1;j<target+1;j++)
		{
			int nonPick = dp[i-1][j];
			int pick = 0;
			if(arr[i]<=j)
				pick = dp[i-1][j-arr[i]];

			dp[i][j] = pick + nonPick;
		}
	}
	return dp[n-1][target];
}


int findWays(vector<int>& arr, int k)
{
	// Write your code here.
	int  n = arr.size();
	vector<vector<int>> dp(n,vector<int>(k+1,0));
	return f(n, k, arr, dp);
}


###############################################################################################

// space optimization


int f(int n, int target, vector<int> &arr, vector<int> &dp)
{

	dp[0] = 1;
	
	if(arr[0]<=target)
		dp[arr[0]] = 1;

    for(int i=1;i<n;i++)
	{
		vector<int> temp = dp;
		for(int j=1;j<target+1;j++)
		{
			int nonPick = dp[j];
			int pick = 0;
			if(arr[i]<=j)
				pick = dp[j-arr[i]];

			temp[j] = pick + nonPick;
		}
		dp = temp;
	}
	return dp[target];
}


int findWays(vector<int>& arr, int k)
{
	// Write your code here.
	int  n = arr.size();
	vector<int> dp(k+1,0);
	return f(n, k, arr, dp);
}
