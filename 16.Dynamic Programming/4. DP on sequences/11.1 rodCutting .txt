

similar to 7, minimum coins to target infinite supply
here max profit from given target where supply infinite 


1. recursion
2. memoization
3. tabulation
4. two rows
5. one row 


int f(int ind, int target,  vector<int>& price){

	if(ind == 0)
		return target*price[0];

	int notPick = f(ind-1, target, price);
	int pick = -1e9;
	if((ind+1) <= target)
		pick = price[ind] + f(ind, target-(ind+1), price);

	return max(notPick, pick);
}
int cutRod(vector<int> &price, int n)
{
	// Write your code here.
	return f(n-1, n, price);
}


TC: exponential >> 2^n 
SC: O(N)

##################################################################################



int f(int ind, int target,  vector<int>& price, vector<vector<int>>& dp){

	if(ind == 0)
		return target*price[0];

	if(dp[ind][target] != -1)	return dp[ind][target];

	int notPick = f(ind-1, target, price, dp);
	int pick = -1e9;
	if((ind+1) <= target)
		pick = price[ind] + f(ind, target-(ind+1), price, dp);

	return dp[ind][target] = max(notPick, pick);
}
int cutRod(vector<int> &price, int n)
{
	// Write your code here.
	vector<vector<int>> dp(n, vector<int>(n+1, -1));
	return f(n-1, n, price, dp);
}


TC: O(n*n)
SC: O(n*n) + n{
    dp = n*n
    stack space = N
}



##########################################################################################





int cutRod(vector<int> &price, int n)
{
	// Write your code here.
	vector<vector<int>> dp(n, vector<int>(n+1, 0));
	for(int target = 0; target<=n; target++)
		dp[0][target] = target*price[0];

	for(int ind = 1; ind<n; ind++){
		for(int target = 0; target<=n; target++){
			
			int notPick = dp[ind-1][target];
			int pick = -1e9;
			if((ind+1) <= target)
				pick = price[ind] + dp[ind][target-(ind+1)];

			dp[ind][target] = max(notPick, pick);
		}
	}
	
	return dp[n-1][n];
}



TC: O(n*n)
SC: O(n*n) {
    dp = n*n
}


####################################################################################





int cutRod(vector<int> &price, int n)
{
	// Write your code here.
	vector<int> prev(n+1, 0), curr(n+1, 0);
	for(int target = 0; target<=n; target++)
		prev[target] = target*price[0];

	for(int ind = 1; ind<n; ind++){
		for(int target = 0; target<=n; target++){
			
			int notPick = prev[target];
			int pick = -1e9;
			if((ind+1) <= target)
				pick = price[ind] + curr[target-(ind+1)];

			curr[target] = max(notPick, pick);
		}
		prev = curr;
	}
	
	return prev[n];
}


TC: O(n*n)
SC: O(n) {
    (curr, prev) = n
}

#########################################################################################





int cutRod(vector<int> &price, int n)
{
	// Write your code here.
	vector<int> prev(n+1, 0);
	for(int target = 0; target<=n; target++)
		prev[target] = target*price[0];

	for(int ind = 1; ind<n; ind++){
		for(int target = 0; target<=n; target++){
			
			int notPick = prev[target];
			int pick = -1e9;
			if((ind+1) <= target)
				pick = price[ind] + prev[target-(ind+1)];

			prev[target] = max(notPick, pick);
		}
	}
	
	return prev[n];
}




TC: O(n*n)
SC: O(n) {
    prev = n 
}


