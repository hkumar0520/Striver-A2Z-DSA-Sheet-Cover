

// recursion


int f(int ind, int w, vector<int> &profit, vector<int> &weight)
{
    // not required below line
    // if(w == 0)  return 0;
    if(ind == 0)   
    {
        int q = w/weight[ind];
        return q*profit[ind];
    }

    int notpick = f(ind-1, w, profit, weight);
    int pick = 0;
    if(weight[ind] <= w)
        pick = profit[ind] + f(ind, w-weight[ind], profit, weight);

    return max(pick, notpick);
}

int unboundedKnapsack(int n, int w, vector<int> &profit, vector<int> &weight){
    // Write Your Code Here.
    return f(n-1, w, profit, weight);
}

###############################################################################################
// memoization

int f(int ind, int w, vector<int> &profit, vector<int> &weight, vector<vector<int>> &dp)
{
    // not required below line
    // if(w == 0)  return 0;
    if(ind == 0)   
    {
        int q = w/weight[ind];
        return q*profit[ind];
    }

    if(dp[ind][w] != -1)    return dp[ind][w];

    int notpick = f(ind-1, w, profit, weight, dp);
    int pick = 0;
    if(weight[ind] <= w)
        pick = profit[ind] + f(ind, w-weight[ind], profit, weight, dp);

    return dp[ind][w] = max(pick, notpick);
}

int unboundedKnapsack(int n, int w, vector<int> &profit, vector<int> &weight){
    // Write Your Code Here.
    vector<vector<int>> dp(n, vector<int>(w+1,-1));
    return f(n-1, w, profit, weight, dp);
}

###############################################################################################
// tabular

int f(int n, int w, vector<int> &profit, vector<int> &weight, vector<vector<int>> &dp)
{

    // if(ind == 0)   
    // {
    //     int q = w/weight[ind];
    //     return q*profit[ind];
    // }
    for(int i=0;i<w+1;i++)
    {
        int q = i/weight[0];
        dp[0][i] = q*profit[0];
    }
    for(int i=1;i<n;i++)
    {
        for(int j=0;j<w+1;j++)
        {
            int notpick = dp[i-1][j];
            int pick = 0;
            if(weight[i]<=j)
                pick = profit[i] + dp[i][j-weight[i]];

            dp[i][j] = max(pick, notpick);
        }
    }
    return dp[n-1][w];

}

int unboundedKnapsack(int n, int w, vector<int> &profit, vector<int> &weight){
    // Write Your Code Here.
    vector<vector<int>> dp(n, vector<int>(w+1,-1));
    return f(n, w, profit, weight, dp);
}



###############################################################################################
//  optimization


int f(int n, int w, vector<int> &profit, vector<int> &weight, vector<int> dp)
{

    // if(ind == 0)   
    // {
    //     int q = w/weight[ind];
    //     return q*profit[ind];
    // }
    for(int i=0;i<w+1;i++)
    {
        int q = i/weight[0];
        dp[i] = q*profit[0];
    }
    for(int i=1;i<n;i++)
    {
        for(int j=0;j<w+1;j++)
        {
            int notpick = dp[j];
            int pick = 0;
            if(weight[i]<=j)
                pick = profit[i] + dp[j-weight[i]];

            dp[j] = max(pick, notpick);
        }
    }
    return dp[w];

}

int unboundedKnapsack(int n, int w, vector<int> &profit, vector<int> &weight){
    // Write Your Code Here.
    vector<int>dp (w+1,-1);
    return f(n, w, profit, weight, dp);
}



