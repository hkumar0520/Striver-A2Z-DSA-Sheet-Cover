


1. recursion
2. memoization
3. tabular
4. optimization




class Solution {
public:
    int f(int ind1, int ind2, string& word1, string& word2){
        int m = word1.size(), n = word2.size();

        if(ind1 == m)   return n - ind2;
        if(ind2 == n)   return m - ind1;
        if(ind1 == m && ind2 == n)   return 0;

        int pick = 1e9;
        int notpick = 1e9;
        if(word1[ind1] == word2[ind2])
            pick = f(ind1+1, ind2+1, word1, word2);

        notpick = min({ 1 + f(ind1+1, ind2, word1, word2), 
                        1 + f(ind1, ind2+1, word1, word2),
                        2 + f(ind1+1, ind2+1, word1, word2) });

        return min(pick, notpick);

    }
    int minDistance(string word1, string word2) {
        
        return f(0, 0, word1, word2);
    }
};


TC: exponential 
SC: O(m + n)


###############################################################################################


class Solution {
public:
    int f(int ind1, int ind2, string& word1, string& word2, vector<vector<int>>& dp){
        int m = word1.size(), n = word2.size();

        if(ind1 == m)   return n - ind2;
        if(ind2 == n)   return m - ind1;
        if(ind1 == m && ind2 == n)   return 0;

        if(dp[ind1][ind2] != -1)    return dp[ind1][ind2];

        int pick = 1e9;
        int notpick = 1e9;
        if(word1[ind1] == word2[ind2])
            pick = f(ind1+1, ind2+1, word1, word2, dp);

        notpick = min({ 1 + f(ind1+1, ind2, word1, word2, dp), 
                        1 + f(ind1, ind2+1, word1, word2, dp),
                        2 + f(ind1+1, ind2+1, word1, word2, dp) });

        return dp[ind1][ind2] = min(pick, notpick);

    }
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m, vector<int>(n, -1));

        return f(0, 0, word1, word2, dp);
    }
};

TC: O(m*n)
SC: O(m*n) + O(m + n){
    dp = m*n 
    stack space = m + n 
}


###############################################################################################


class Solution {
public:

    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

        for(int i = 0; i<=m; i++)
            dp[i][n] = m - i;

        for(int i = 0; i<=n; i++)
            dp[m][i] = n - i;


        for(int ind1 = m-1; ind1 >= 0; ind1--){
            for(int ind2 = n-1; ind2 >= 0; ind2--){

                int pick = 1e9;
                int notpick = 1e9;
                if(word1[ind1] == word2[ind2])
                    pick = dp[ind1+1][ind2+1];

                notpick = min({ 1 + dp[ind1+1][ind2], 
                                1 + dp[ind1][ind2+1],
                                2 + dp[ind1+1][ind2+1] });

                dp[ind1][ind2] = min(pick, notpick);
            }
        }

        return dp[0][0];
    }
};

TC: O(m*n)
SC: O(m*n)


###############################################################################################

class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<int> curr(n+1, 0), prev(n+1, 0);

        for(int i = 0; i<=n; i++)
            prev[i] = n - i;

        for(int ind1 = m-1; ind1 >= 0; ind1--){
            curr[n] = m - ind1;
            for(int ind2 = n-1; ind2 >= 0; ind2--){

                int pick = 1e9;
                int notpick = 1e9;
                if(word1[ind1] == word2[ind2])
                    pick = prev[ind2+1];

                notpick = min({ 1 + prev[ind2], 
                                1 + curr[ind2+1],
                                2 + prev[ind2+1] });

                curr[ind2] = min(pick, notpick);
            }
            prev = curr;
        }

        return curr[0];
    }
};

TC: O(m*n)
SC: O(2*n)


###############################################################################################



