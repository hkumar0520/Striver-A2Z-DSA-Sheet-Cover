

// recursion

long f(int ind, int buy, vector<int> &values, int n)
{
    if(ind >= n)    return 0;

    long opt1 = 0, opt2 = 0;
    if(buy == 0)
    {
        opt1 = f(ind+1,buy,values,n);
        opt2 = -values[ind] + f(ind+1,1,values,n);
    }
    else
    {
        opt1 = f(ind+1,buy,values,n);
        opt2 = values[ind] + f(ind+2,0,values,n);
    }
    return max(opt1,opt2);
}

int stockProfit(vector<int> &prices){
    // Write your code here.
    int n = prices.size();
    return f(0, 0, prices, n);
}

###############################################################################################
// memoization

#include <bits/stdc++.h>

int f(int ind, int buy, vector<int> &values, int n, vector<vector<long>> &dp)
{
    if(ind >= n)    return 0;

    if(dp[ind][buy] != -1)   return dp[ind][buy];

    int opt1 = 0, opt2 = 0;
    if(buy == 0)
    {
        opt1 = f(ind+1,buy,values,n,dp);
        opt2 = -values[ind] + f(ind+1,1,values,n,dp);
    }
    else
    {
        opt1 = f(ind+1,buy,values,n,dp);
        opt2 = values[ind] + f(ind+2,0,values,n,dp);
    }
    return dp[ind][buy] = max(opt1,opt2);
}

int stockProfit(vector<int> &prices){
    // Write your code here.
    int n = prices.size();
    vector<vector<long>> dp(n,vector<long>(2,-1));
    return f(0, 0, prices, n,dp);
}


###############################################################################################
// tabular


###############################################################################################
// optimization














###############################################################################################
only half correct recursion

long f(int ind, int buy, vector<int> &values, int n, int cooldown)
{
    if(ind == n)    return 0;

    long opt1 = 0, opt2 = 0;
    if(cooldown == 1)
        opt1 = f(ind+1,buy,values,n,0);
    else
    {
        if(buy == 0)
        {
            opt1 = f(ind+1,buy,values,n,cooldown);
            opt2 = -values[ind] + f(ind+1,1,values,n,cooldown);
        }
        else
        {
            opt1 = f(ind+1,buy,values,n,cooldown);
            opt2 = values[ind] + f(ind+1,0,values,n,1);
        }
    }
    return max(opt1,opt2);
}



int stockProfit(vector<int> &prices){
    // Write your code here.    
    int n = prices.size();
    return f(0, 0, prices, n,0);

}



// not working memo 




int f(int ind, int buy, vector<int> &values, int n, int cooldown,vector<vector<vector<int>>> dp)
{
    if(ind == n)    return 0;

    if(dp[ind][buy][cooldown] != -1)    return dp[ind][buy][cooldown];

    int opt1 = 0, opt2 = 0;
    if(cooldown == 1)
        opt1 = f(ind+1,buy,values,n,0,dp);
    else
    {
        if(buy == 0)
        {
            opt1 = f(ind+1,buy,values,n,cooldown,dp);
            opt2 = -values[ind] + f(ind+1,1,values,n,cooldown,dp);
        }
        else
        {
            opt1 = f(ind+1,buy,values,n,cooldown,dp);
            opt2 = values[ind] + f(ind+1,0,values,n,1,dp);
        }
    }
    return dp[ind][buy][cooldown] = max(opt1,opt2);
}



int stockProfit(vector<int> &prices){
    // Write your code here.    
    int n = prices.size();
    vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(2,-1)));
    return f(0, 0, prices, n, 0, dp);

}



