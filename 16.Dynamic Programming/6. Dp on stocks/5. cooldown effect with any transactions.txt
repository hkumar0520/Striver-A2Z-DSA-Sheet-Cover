

// recursion

long f(int ind, int buy, vector<int> &values, int n)
{
    if(ind >= n)    return 0;

    long opt1 = 0, opt2 = 0;
    if(buy == 0)
    {
        opt1 = f(ind+1,buy,values,n);
        opt2 = -values[ind] + f(ind+1,1,values,n);
    }
    else
    {
        opt1 = f(ind+1,buy,values,n);
        opt2 = values[ind] + f(ind+2,0,values,n);
    }
    return max(opt1,opt2);
}

int stockProfit(vector<int> &prices){
    // Write your code here.
    int n = prices.size();
    return f(0, 0, prices, n);
}

###############################################################################################
// memoization

#include <bits/stdc++.h>

int f(int ind, int buy, vector<int> &values, int n, vector<vector<long>> &dp)
{
    if(ind >= n)    return 0;

    if(dp[ind][buy] != -1)   return dp[ind][buy];

    int opt1 = 0, opt2 = 0;
    if(buy == 0)
    {
        opt1 = f(ind+1,buy,values,n,dp);
        opt2 = -values[ind] + f(ind+1,1,values,n,dp);
    }
    else
    {
        opt1 = f(ind+1,buy,values,n,dp);
        opt2 = values[ind] + f(ind+2,0,values,n,dp);
    }
    return dp[ind][buy] = max(opt1,opt2);
}

int stockProfit(vector<int> &prices){
    // Write your code here.
    int n = prices.size();
    vector<vector<long>> dp(n,vector<long>(2,-1));
    return f(0, 0, prices, n,dp);
}


###############################################################################################
// tabular

class Solution {
public:
    int ff(vector<int>& prices, vector<vector<int>>& dp)
    {
        int n= prices.size();
        for(int i=n-1;i>=0;i--)
        {
            for(int buy = 0;buy<2;buy++)
            {
                if(buy ==0 )
                {
                    dp[i][buy] = max(0+dp[i+1][buy],
                                    -prices[i]+dp[i+1][1]);
                }
                else
                {
                    dp[i][buy] = max(0+dp[i+1][buy],
                                +prices[i]+dp[i+2][0]);
                }
            }
        }
        return dp[0][0];
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n+2,vector<int>(2,0));
        return ff(prices,dp);
    }
};


###############################################################################################
// optimization


class Solution {
public:
    int ff(vector<int>& prices, vector<vector<int>>& dp)
    {
        vector<int> curr(2,0);
        vector<int> ahead(2,0);
        vector<int> aheadnext(2,0);
        int n= prices.size();
        for(int i=n-1;i>=0;i--)
        {
            for(int buy = 0;buy<2;buy++)
            {
                if(buy ==0 )
                {
                    curr[buy] = max(0+ahead[buy],
                                    -prices[i]+ahead[1]);
                }
                else
                {
                    curr[buy] = max(0+ahead[buy],
                                +prices[i]+aheadnext[0]);
                }
            }
            aheadnext = ahead;
            ahead = curr;
        }
        return curr[0];
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n+2,vector<int>(2,0));
        return ff(prices,dp);
    }
};











###############################################################################################
only half correct recursion

long f(int ind, int buy, vector<int> &values, int n, int cooldown)
{
    if(ind == n)    return 0;

    long opt1 = 0, opt2 = 0;
    if(cooldown == 1)
        opt1 = f(ind+1,buy,values,n,0);
    else
    {
        if(buy == 0)
        {
            opt1 = f(ind+1,buy,values,n,cooldown);
            opt2 = -values[ind] + f(ind+1,1,values,n,cooldown);
        }
        else
        {
            opt1 = f(ind+1,buy,values,n,cooldown);
            opt2 = values[ind] + f(ind+1,0,values,n,1);
        }
    }
    return max(opt1,opt2);
}



int stockProfit(vector<int> &prices){
    // Write your code here.    
    int n = prices.size();
    return f(0, 0, prices, n,0);

}



// not working memo 




int f(int ind, int buy, vector<int> &values, int n, int cooldown,vector<vector<vector<int>>> dp)
{
    if(ind == n)    return 0;

    if(dp[ind][buy][cooldown] != -1)    return dp[ind][buy][cooldown];

    int opt1 = 0, opt2 = 0;
    if(cooldown == 1)
        opt1 = f(ind+1,buy,values,n,0,dp);
    else
    {
        if(buy == 0)
        {
            opt1 = f(ind+1,buy,values,n,cooldown,dp);
            opt2 = -values[ind] + f(ind+1,1,values,n,cooldown,dp);
        }
        else
        {
            opt1 = f(ind+1,buy,values,n,cooldown,dp);
            opt2 = values[ind] + f(ind+1,0,values,n,1,dp);
        }
    }
    return dp[ind][buy][cooldown] = max(opt1,opt2);
}



int stockProfit(vector<int> &prices){
    // Write your code here.    
    int n = prices.size();
    vector<vector<vector<int>>> dp(n,vector<vector<int>>(2,vector<int>(2,-1)));
    return f(0, 0, prices, n, 0, dp);

}



