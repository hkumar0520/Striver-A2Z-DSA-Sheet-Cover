#include <bits/stdc++.h> 

// recursion time limit exceeded
#include <bits/stdc++.h> 

int f(int n)
{
    if(n<= 1)   return 1;

    return f(n-1) + f(n-2);
}
int countDistinctWays(int nStairs) {
    //  Write your code here.
   return f(nStairs);
}

TC: O(2^(n-1))
SC: O(n){
    n = stack space 
}


###############################################################################################
// memoization approach
#include <bits/stdc++.h> 

int f(int n, vector<int>& dp)
{
    if(n<= 1)   return 1;

    if(dp[n] != -1)   return dp[n];

    dp[n] = f(n-1, dp) + f(n-2, dp);
    return dp[n];
    
}
int countDistinctWays(int nStairs) {
    //  Write your code here.

    vector<int> dp(nStairs+1, -1);

   return f(nStairs,dp);
}

TC: O(n)
SC: O(n) + O(n) {
    n = stack space
    n = dp array space 
}

###############################################################################################
//  tabular approach

#include <bits/stdc++.h> 
int countDistinctWays(int nStairs) {
    //  Write your code here.

    vector<int> dp(nStairs+1, 0);

    dp[0] = 1;

    for(int i=1; i<=nStairs; i++){
        dp[i] += dp[i-1];
        if(i>1)
            dp[i] += dp[i-2];
    }

    return dp[nStairs];
}

TC: O(n)
SC: O(n)


#################################################################################
// optimized approach

#include <bits/stdc++.h> 
int countDistinctWays(int nStairs) {
    //  Write your code here.
    vector<int> dp(nStairs+1, 0);

    int prev = 1, prevTwo = 0;

    for(int i=1; i<=nStairs; i++){
        int curr = prev;
        if(i>1)
            curr += prevTwo;

        prevTwo = prev;
        prev = curr;
    }

    return prev;
}

TC: O(n)
SC: O(1)


