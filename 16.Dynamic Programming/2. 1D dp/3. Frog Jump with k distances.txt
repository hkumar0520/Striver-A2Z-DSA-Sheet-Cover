
// recursion 

int f(int ind, vector<int> hgs,  int k)
{
    if(ind == 0) return 0;

    int minimum = INT_MAX;
    for(int j = 1;j<=k;j++)
    {
        if((ind-j)>=0)
        {
            int value = f(ind-j,hgs, k) + abs(hgs[ind]-hgs[ind-j]);
            minimum = min(minimum, value);
        }
    }

    return minimum;
}

int minimizeCost(int n, int k, vector<int> &height){


    return f(n-1, height, k);

    // Write your code here.
}


TC: O( k ^ (n-1)) = O( k^ n){
    k choices at every index so for large number n
    k^n goes
}
SC: O(n)


###############################################################################################

// memoization
int f(int ind, vector<int> hgs, vector<int> &dp, int k)
{
    if(ind == 0) return 0;

    if(dp[ind]!=-1) return dp[ind];

    int minimum = INT_MAX;
    for(int j = ind-1; j>=0 && (ind-j)<=k ; j--)
    {
        int value = f(j,hgs, dp, k) + abs(hgs[ind]-hgs[j]);
        minimum = min(minimum, value);
    }

    return dp[ind] = minimum;
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n-1, height, dp, k);

    // Write your code here.
}

TC: O(n*k)
SC: O(n) + O(n){
    n = stack space
    n = dp array
}

###############################################################################################
//another memoization approach


int f(int ind, vector<int> hgs, vector<int> &dp, int k)
{
    if(ind == 0) return 0;

    if(dp[ind]!=-1) return dp[ind];

    int minimum = INT_MAX;
    for(int j = 1;j<=k;j++)
    {
        if((ind-j)>=0)
        {
            int value = f(ind-j,hgs, dp, k) + abs(hgs[ind]-hgs[ind-j]);
            minimum = min(minimum, value);
        }
    }

    return dp[ind] = minimum;
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n-1, height, dp, k);

    // Write your code here.
}

TC: O(n*k)
SC: O(n) + O(n){
    n = stack space
    n = dp array
}

###############################################################################################
// Tabular approach

int f(int n, vector<int> hgs, int k)
{
    vector<int> dp(n, -1);

    dp[0] = 0;
    for(int ind=1;ind<n;ind++)
    {
        int minimum = INT_MAX;
        for(int j = 1;j<=k;j++)
        {
            if((ind-j)>=0)
            {
                int value = dp[ind-j] + abs(hgs[ind]-hgs[ind-j]);
                minimum = min(minimum, value);
            }
        }
        dp[ind] = minimum;
    }
    return dp[n-1];
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n, height, k);

    // Write your code here.
}


TC: O(n*k)
SC: O(n) {
    n = dp array
}

// table approach



##############################################################################################




#include <bits/stdc++.h>
int f(int n, vector<int> hgs, int k)
{
    vector<int> dp(k, -1);

    dp[0] = 0;
    for(int i = 1; i<k; i++ ){
        int minimum = INT_MAX;
        for(int j = 1; j<=k; j++){
            if((i-j)>=0){
                int value = dp[i-j] + abs(hgs[i] - hgs[i-j]);
                minimum = min(minimum, value);
            }
        }
        dp[i] = minimum;
    }

    for(int ind=k;ind<n;ind++)
    {
        int minimum = INT_MAX;
        for(int j = 1;j<=k;j++)
        {
            if((ind-j)>=0)
            {
                int value = dp[k-j] + abs(hgs[ind]-hgs[ind-j]);
                minimum = min(minimum, value);
            }
        }
        dp.push_back( minimum );
        if(dp.size() > k)
            dp.erase(dp.begin());
    }
    return dp[k-1];
}

int minimizeCost(int n, int k, vector<int> &height){

    return f(n, height, k);
}

TC: O(n*k)
SC: O(k)



