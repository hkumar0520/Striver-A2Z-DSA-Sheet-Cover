
int f(int ind, vector<int> hgs, vector<int> &dp, int k)
{
    if(ind == 0) return 0;

    if(dp[ind]!=-1) return dp[ind];

    int minimum = INT_MAX;
    for(int j = ind-1; j>=0 && (ind-j)<=k ; j--)
    {
        int value = f(j,hgs, dp, k) + abs(hgs[ind]-hgs[j]);
        minimum = min(minimum, value);
    }

    return dp[ind] = minimum;
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n-1, height, dp, k);

    // Write your code here.
}


###############################################################################################
//another memoization approach


int f(int ind, vector<int> hgs, vector<int> &dp, int k)
{
    if(ind == 0) return 0;

    if(dp[ind]!=-1) return dp[ind];

    int minimum = INT_MAX;
    for(int j = 1;j<=k;j++)
    {
        if((ind-j)>=0)
        {
            int value = f(ind-j,hgs, dp, k) + abs(hgs[ind]-hgs[ind-j]);
            minimum = min(minimum, value);
        }
    }

    return dp[ind] = minimum;
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n-1, height, dp, k);

    // Write your code here.
}

###############################################################################################
// Tabular approach

int f(int n, vector<int> hgs, int k)
{
    vector<int> dp(n, -1);

    dp[0] = 0;
    for(int ind=1;ind<n;ind++)
    {
        int minimum = INT_MAX;
        for(int j = 1;j<=k;j++)
        {
            if((ind-j)>=0)
            {
                int value = dp[ind-j] + abs(hgs[ind]-hgs[ind-j]);
                minimum = min(minimum, value);
            }
        }
        dp[ind] = minimum;
    }
    return dp[n-1];
}

int minimizeCost(int n, int k, vector<int> &height){

    vector<int> dp(n,-1);

    return f(n, height, k);

    // Write your code here.
}

// table approach