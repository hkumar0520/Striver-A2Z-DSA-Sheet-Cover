
https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description/

1. memo limit exceed due to -> path + "L"/"R" in recursion, creates a new string every time
2. correct



/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {
        
        if(root == nullptr || root->val == p || root->val == q)
            return root;

        TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);

        if(leftLCA && rightLCA)
            return root;

        return leftLCA ? leftLCA : rightLCA;
    }
    void findRootToNode(TreeNode* node, int dstValue, string& ans, string path){
        if(node == nullptr)     return ;
        if(node->val == dstValue){
            ans = path;
            return;
        } 

        findRootToNode(node->left, dstValue, ans, path + "L"),
        findRootToNode(node->right, dstValue, ans, path + "R");
    }
    string getDirections(TreeNode* root, int startValue, int destValue) {
        TreeNode* lca = lowestCommonAncestor(root, startValue, destValue);

        string pathToVal = "";
        findRootToNode(lca, startValue, pathToVal, "");

        string ans(pathToVal.size(), 'U');
        findRootToNode(lca, destValue, pathToVal, "");
        
        ans += pathToVal;
        return ans;
    }
};



#########################################################################################


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, int p, int q) {
        
        if(root == nullptr || root->val == p || root->val == q)
            return root;

        TreeNode* leftLCA = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightLCA = lowestCommonAncestor(root->right, p, q);

        if(leftLCA && rightLCA)
            return root;

        return leftLCA ? leftLCA : rightLCA;
    }
    void findRootToNode(TreeNode* node, int dstValue, string& ans, string& path){
        if(node == nullptr)     return ;
        if(node->val == dstValue){
            ans = path;
            return;
        } 

        path += "L";
        findRootToNode(node->left, dstValue, ans, path),
        path.pop_back();

        path += "R";
        findRootToNode(node->right, dstValue, ans, path);
        path.pop_back();
    }
    string getDirections(TreeNode* root, int startValue, int destValue) {
        TreeNode* lca = lowestCommonAncestor(root, startValue, destValue);

        string pathToVal = "";
        string path = "";
        findRootToNode(lca, startValue, pathToVal, path);

        string ans(pathToVal.size(), 'U');
        findRootToNode(lca, destValue, pathToVal, path);
        
        ans += pathToVal;
        return ans;
    }
};


TC: O(n) + O(n) + O(n)
SC: 3*O(n)

