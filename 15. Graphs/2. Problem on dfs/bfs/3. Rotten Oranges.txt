not dfs problem , 2 = rotten, 1 = fresh, 0 - wall

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size(),m = grid[0].size(), totalcnt = 0, cnt = 0, days = 0;
        queue<vector<int>> qtraverse;
        for(int i=0;i<n;i++)
        {
            for(int j = 0;j<m;j++)
            {
                // totalcnt is total of rotten + fresh oranges
                if(grid[i][j] != 0) totalcnt++;
                if(grid[i][j] == 2) qtraverse.push({i,j});
            }
        }
        int ax[4] = {-1,0,1,0};
        int by[4] = {0,1,0,-1};
        while(!qtraverse.empty())
        {
            int k = qtraverse.size();
            cnt += k;
            while(k--)
            {
                vector<int> node = qtraverse.front();
                qtraverse.pop();
                int x= node[0], y = node[1];
                for(int i=0;i<4;i++)
                {
                    int nx = x + ax[i], ny = y + by[i];
                    if(nx>=0 && ny>=0 && nx<n && ny<m && grid[nx][ny] == 1)
                    {
                        grid[nx][ny] = 2;
                        qtraverse.push({nx,ny});
                    }
                }
            }
            if(!qtraverse.empty())  days++;
        }
        // compare cnt(rotten+fresh(which rot)) == totalcnt
        return totalcnt == cnt? days:-1;
    }
};

###################################################################

my earlier soln 

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int countt=0,m=grid.size(),n=grid[0].size();
        queue<vector<int>> q;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==2)
                {
                    // x,y,steps 
                    q.push(vector<int>{i,j,0});
                }
                else if(grid[i][j]==1)
                    countt++;
            }
        }
        if(countt==0)
            return 0;
        int minsteps=INT_MIN;
        int a[4]={-1,0,1,0};
        int b[4]={0,1,0,-1};
        while(!q.empty())
        {
            vector<int> current=q.front();
            q.pop();
            int x=current[0],y=current[1],steps=current[2];
            minsteps=max(minsteps,steps+1);
            if(countt==0)
                break;
            for(int i=0;i<4;i++)
            {
                int newx=x+a[i];
                int newy=y+b[i];
                if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]==1)
                {
                    grid[newx][newy]=2;
                    q.push(vector<int>{newx,newy,steps+1});
                    countt--;
                }
            }
        }
        if(countt==0)
            return minsteps;
        return -1;
    }
};


Time Complexity: O ( n x n ) x 4    

Reason: Worst-case - We will be making each fresh orange rotten in the grid and for each rotten orange will check in 4 directions

Space Complexity: O ( n x n )

Reason: worst-case -  If all oranges are Rotten, we will end up pushing all rotten oranges into the Queue data structure


##################################3