
// leetcode memory limit exceed 33/37

class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> st(wordList.begin(),wordList.end());
        st.insert(beginWord);
        if(st.find(endWord) == st.end())
            return {};

        queue<vector<string>> qtraverse;
        qtraverse.push({beginWord});

        vector<string> vis;
        vis.push_back(beginWord);

        vector<vector<string>> ans;

        while(!qtraverse.empty())
        {
            int qsize = qtraverse.size();

            // clearing the vis
            for(string str: vis)
                st.erase(str);
            vis.clear();
            

            while(qsize--)
            {
                vector<string> node = qtraverse.front();
                qtraverse.pop();

                string word = node.back();
                if(word == endWord)
                {
                    if(ans.size() == 0)     // in case of empty ans, put the first sequence to achive endWord
                        ans.push_back(node);
                    else if(ans[0].size() == node.size())  // in  case of not empty, first ans[0] size == node size
                        ans.push_back(node);
                }
                else
                {
                    for(int i=0;i<word.size();i++)
                    {
                        string  str =word;
                        for(int j=0;j<26;j++)
                        {
                            str[i] = (char)('a'+j);
                            if(st.find(str) != st.end())
                            {
                                node.push_back(str);
                                qtraverse.push(node);
                                node.pop_back();

                                vis.push_back(str);
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }
};

################################################################################

time limit exceed 33/37



class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        wordList.push_back(beginWord);
        if(find(wordList.begin(),wordList.end(),endWord) == wordList.end())
            return {};

        queue<vector<string>> qtraverse;
        qtraverse.push({beginWord});

        vector<string> vis;
        vis.push_back(beginWord);

        vector<vector<string>> ans;

        while(!qtraverse.empty())
        {
            int qsize = qtraverse.size();

            // clearing the vis
            for(string str: vis)
            {
                if(find(wordList.begin(), wordList.end(), str) != wordList.end())
                {
                    int index = find(wordList.begin(), wordList.end(), str) - wordList.begin();
                    wordList.erase(wordList.begin() + index);
                }
            }
            vis.clear();
            

            while(qsize--)
            {
                vector<string> node = qtraverse.front();
                qtraverse.pop();

                string word = node.back();
                if(word == endWord)
                {
                    if(ans.size() == 0)     // in case of empty ans, put the first sequence to achive endWord
                        ans.push_back(node);
                    else if(ans[0].size() == node.size())  // in  case of not empty, first ans[0] size == node size
                        ans.push_back(node);
                }
                else
                {
                    for(int i=0;i<word.size();i++)
                    {
                        string  str =word;
                        for(int j=0;j<26;j++)
                        {
                            str[i] = (char)('a'+j);
                            if(find(wordList.begin(), wordList.end(), str) != wordList.end())
                            {
                                node.push_back(str);
                                qtraverse.push(node);
                                node.pop_back();

                                vis.push_back(str);
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }
};

