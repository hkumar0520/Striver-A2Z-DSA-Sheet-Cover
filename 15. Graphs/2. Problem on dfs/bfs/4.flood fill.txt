class Solution {
public:
    vector<vector<int>> bfs(vector<vector<int>>& image, vector<int> start,int startColor, int targetColor)
    {
        int m = image.size(), n = image[0].size();
        vector<vector<int>> ans = image;
        vector<vector<int>> vis(m,vector<int>(n,0));
        queue<vector<int>> qtraverse;
        qtraverse.push(start);
        ans[start[0]][start[1]] = targetColor;
        vis[start[0]][start[1]] = 1;
        int ax[4] = {-1,0,1,0};
        int by[4] = {0,1,0,-1};
        while(!qtraverse.empty())
        {
            vector<int> node = qtraverse.front();
            qtraverse.pop();
            int x = node[0], y = node[1];
            for(int i=0;i<4;i++)
            {
                int nx = x + ax[i];
                int ny = y + by[i];
                if(nx>=0 && ny >=0 && nx<m && ny<n && ans[nx][ny] == startColor && !vis[nx][ny])
                {
                    qtraverse.push({nx,ny});
                    ans[nx][ny] = targetColor;
                    vis[nx][ny] = 1;
                }
            }
        }
        return  ans;
    }
    void dfs(vector<vector<int>>& ans, vector<vector<int>>& vis,vector<int> start,int startColor, int targetColor)
    {
        ans[start[0]][start[1]] = targetColor;
        vis[start[0]][start[1]] = 1;

        int ax[4] = {-1,0,1,0};
        int by[4] = {0,1,0,-1};
        int m = ans.size(),n = ans[0].size();
        for(int i=0;i<4;i++)
        {
            int nx = start[0] + ax[i];
            int ny = start[1] + by[i];
            if(nx>=0 && ny >=0 && nx<m && ny<n && ans[nx][ny] == startColor && !vis[nx][ny])
            {
                dfs(ans,vis,{nx,ny},startColor,targetColor);
            }
        }
    }
    vector<vector<int>> dfsapproach(vector<vector<int>>& image, vector<int> start,int startColor, int targetColor)
    {
        int m = image.size(),n = image[0].size();
        vector<vector<int>> ans = image;
        vector<vector<int>> vis(m,vector<int>(n,0));
        dfs(ans,vis,start,startColor,targetColor);
        return ans;
    }
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int startingColor = image[sr][sc];
        //return bfs(image,{sr,sc}, startingColor, color);
        return dfsapproach(image,{sr,sc}, startingColor, color);
    }
};

### Time Complexity

The time complexity for both the **BFS** and **DFS** approaches can be analyzed as follows:

1. **Grid Traversal**:
   - Each cell in the grid is visited at most once, either by the BFS queue or by the DFS recursion. 
   - In the worst case, all cells in the grid are processed, which takes \(O(m \times n)\), where \(m\) is the number of rows and \(n\) is the number of columns.

2. **Neighbor Checking**:
   - For each cell, up to four neighbors are checked, which is a constant operation (\(O(1)\)).

**Overall Time Complexity**:
\[
O(m \times n)
\]

---

### Space Complexity

The space complexity for both approaches is determined by:

1. **Visited Array**:
   - A 2D vector `vis` of size \(m \times n\) is used to track visited cells. This takes \(O(m \times n)\) space.

2. **Queue for BFS**:
   - In the worst case, the queue can store all cells in the grid, which takes \(O(m \times n)\) space.

3. **Recursion Stack for DFS**:
   - In the worst case (when the entire grid is connected and the recursion depth equals the number of cells), the recursion stack requires \(O(m \times n)\) space.

**Overall Space Complexity**:
\[
O(m \times n)
\]

---

### Summary
- **Time Complexity**: \(O(m \times n)\)
- **Space Complexity**: \(O(m \times n)\)

Both the BFS and DFS implementations have the same time and space complexity, but their performance can differ in practice based on the structure of the grid and the specific problem constraints.

#############################################################

#include<bits/stdc++.h>
using namespace std;

class Solution {
private:
    void dfs(int row, int col, vector<vector<int>>&ans,
     vector<vector<int>>& image, int newColor, int delRow[], int delCol[],
     int iniColor) {
        // color with new color
        ans[row][col] = newColor; 
        int n = image.size();
        int m = image[0].size(); 
        // there are exactly 4 neighbours
        for(int i = 0;i<4;i++) {
            int nrow = row + delRow[i]; 
            int ncol = col + delCol[i]; 
            // check for valid coordinate 
            // then check for same initial color and unvisited pixel
            if(nrow>=0 && nrow<n && ncol>=0 && ncol < m && 
            image[nrow][ncol] == iniColor && ans[nrow][ncol] != newColor) {
                dfs(nrow, ncol, ans, image, newColor, delRow, delCol, iniColor); 
            }
        }
    }
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, 
    int sr, int sc, int newColor) {
        // get initial color
        int iniColor = image[sr][sc]; 
        vector<vector<int>> ans = image; 
        // delta row and delta column for neighbours
        int delRow[] = {-1, 0, +1, 0};
        int delCol[] = {0, +1, 0, -1}; 
        dfs(sr, sc, ans, image, newColor, delRow, delCol, iniColor); 
        return ans; 
    }
};

int main(){
		
	vector<vector<int>>image{
	    {1,1,1},
	    {1,1,0},
	    {1,0,1}
	};
	
// sr = 1, sc = 1, newColor = 2  	
	Solution obj;
	vector<vector<int>> ans = obj.floodFill(image, 1, 1, 2);
	for(auto i: ans){
		for(auto j: i)
			cout << j << " ";
		cout << "\n";
	}
	
	return 0;
}
Output:

2 2 2
2 2 0 
2 0 1
Time Complexity: O(NxM + NxMx4) ~ O(N x M)

For the worst case, all of the pixels will have the same colour, so DFS function will be called for (N x M) nodes and for every node we are traversing for 4 neighbours, so it will take O(N x M x 4) time.

Space Complexity: O(N x M) + O(N x M)

O(N x M) for copied input array and recursive stack space takes up N x M locations at max. 

