// connected components

class Solution {
public:
    // all test cases passed  
    void bfs(int start,vector<vector<int>>& isConnected,vector<int>& vis)
    {
        int n = isConnected.size();
        queue<int> qtraverse;
        qtraverse.push(start);
        vis[start] = 1;
        while(!qtraverse.empty())
        {
            int  node = qtraverse.front();
            qtraverse.pop();
            for(int j = 0;j<n;j++)
            {
                if(isConnected[node][j] == 1 && !vis[j])
                {
                    qtraverse.push(j);
                    vis[j] = 1;
                }
            }
        }
    }
    // dfs all test cases passed
     void dfs(int start,vector<vector<int>>& isConnected,vector<int>& vis)
    {
        vis[start] = 1;
        for(int j = 0;j<isConnected.size();j++)
        {
            if(isConnected[start][j] == 1 && !vis[j])
            {
                dfs(j,isConnected,vis);
            }
        }
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        
        int n = isConnected.size();
        vector<int> vis(n,0);
        int totalProvince = 0;
        for(int i=0;i<n;i++)
        {
            if(!vis[i])
            {
                totalProvince++;
                bfs(i,isConnected,vis);
                // dfs(i,isConnected,vis);
            }
        }
        return totalProvince;
    }
};


Let's analyze the time and space complexity of the provided code.

### 1. **BFS Function (`bfs(int start, vector<vector<int>>& isConnected, vector<int>& vis)`)**

- **Time Complexity**:
  - The function performs a breadth-first search (BFS) starting from a given node. For each node, it explores its neighbors (all other nodes in the graph).
  - In the worst case, every node will be visited exactly once, and for each node, the algorithm checks all of its neighbors (i.e., iterates over the entire row in the adjacency matrix `isConnected`).
  - The outer loop runs in **O(n)**, where `n` is the number of nodes.
  - The inner loop checks all `n` neighbors for each node.
  - Therefore, the total time complexity of the BFS function is **O(n^2)**, where `n` is the number of nodes (since every node checks every other node once).

- **Space Complexity**:
  - The space complexity of BFS is determined by the `vis` array, which takes **O(n)** space to track whether a node has been visited.
  - The queue can hold up to **n** nodes in the worst case (when the graph is a single connected component), so it takes **O(n)** space as well.
  - Therefore, the space complexity for the BFS function is **O(n)**.

### 2. **DFS Function (`dfs(int start, vector<vector<int>>& isConnected, vector<int>& vis)`)**

- **Time Complexity**:
  - The DFS function is a depth-first search. For each node, it recursively explores all of its neighbors.
  - Similar to BFS, every node is visited once, and for each node, we check all of its neighbors (again iterating over the adjacency matrix).
  - The time complexity is **O(n^2)**, where `n` is the number of nodes, because we check every node and every possible connection (edge) in the graph (the adjacency matrix is `n x n`).

- **Space Complexity**:
  - The space complexity is determined by the `vis` array (which takes **O(n)** space) and the recursion stack used by DFS.
  - In the worst case, the recursion stack could grow to the depth of the entire graph (i.e., `n` if the graph is a chain), so the recursion stack space is **O(n)**.
  - Therefore, the space complexity of DFS is **O(n)** due to the `vis` array and the recursion stack.

### 3. **Main Function (`findCircleNum(vector<vector<int>>& isConnected)`)**

- **Time Complexity**:
  - The main function starts by initializing the `vis` array and then iterates over all nodes (`n` nodes) with a for loop. For each node, it calls either the `bfs` or `dfs` function (only one is active in the code, but both are analyzed).
  - For each unvisited node, either `bfs` or `dfs` is called, both of which have a time complexity of **O(n^2)**.
  - The loop runs for `n` nodes, and in the worst case, every call to `bfs` or `dfs` processes all `n` nodes and checks all edges.
  - Therefore, the total time complexity is **O(n^2)**. This is because even if the BFS/DFS is called for each node, each node and edge are processed only once, leading to a combined time complexity of **O(n^2)** for the entire process.

- **Space Complexity**:
  - The space complexity is determined by the `vis` array (which takes **O(n)** space) and the adjacency matrix `isConnected` (which is a **O(n^2)** space data structure).
  - The space complexity is **O(n^2)** because the adjacency matrix `isConnected` takes **O(n^2)** space, and the `vis` array only takes **O(n)** space, which is dominated by the adjacency matrix.
  
---

### Final Summary

- **Time Complexity**: **O(n^2)**, where `n` is the number of nodes in the graph. This comes from:
  - Iterating over all nodes (`n` iterations).
  - Calling BFS/DFS for each unvisited node, where each call processes all nodes and edges in the graph, leading to **O(n^2)**.

- **Space Complexity**: **O(n^2)**, primarily due to the space required for the adjacency matrix `isConnected`. The `vis` array takes **O(n)** space, and the queue/recursion stack in BFS/DFS takes **O(n)** space, but these are dominated by the adjacency matrix.



#############################################################################
####################################


using adjacency list 

class Solution {
public:
    // all test cases passed  
    void bfs(int start,vector<vector<int>>& graph,vector<int>& vis)
    {
        queue<int> qtraverse;
        qtraverse.push(start);
        vis[start] = 1;
        while(!qtraverse.empty())
        {
            int  node = qtraverse.front();
            qtraverse.pop();
            for(int currNode: graph[node])
            {
                if(!vis[currNode])
                {
                    qtraverse.push(currNode);
                    vis[currNode] = 1;
                }
            }
        }
    }
    // dfs all test cases passed
     void dfs(int start,vector<vector<int>>& graph,vector<int>& vis)
    {
        vis[start] = 1;
        for(int currNode: graph[start])
        {
            if(!vis[currNode]){
                dfs(currNode,graph,vis);
            }
        }
    }
    void getGraph(vector<vector<int>>& isConnected, vector<vector<int>>& graph) {
        int n = isConnected.size();
        for(int i=0; i<n; i++){
            for(int j =0; j<n; j++){
                if(i == j)  continue;
                if(isConnected[i][j]){
                    graph[i].push_back(j);
                    graph[j].push_back(i);
                }
            }
        }
    }
    int findCircleNum(vector<vector<int>>& isConnected) {
        
        int n = isConnected.size();
        vector<vector<int>> graph(n);
        getGraph(isConnected, graph);

        vector<int> vis(n,0);
        int totalProvince = 0;

        for(int i=0;i<n;i++)
        {
            if(!vis[i])
            {
                totalProvince++;
                bfs(i,graph,vis);
            }
        }
        return totalProvince;
    }
};


Let's break down the **time complexity** and **space complexity** of the given code.

### Functions Breakdown

#### 1. **`bfs(int start, vector<vector<int>>& graph, vector<int>& vis)`**
   - **Time Complexity**:  
     - The BFS function processes each node and its neighbors. It starts from a given node, pushes it into the queue, and explores all reachable nodes. 
     - Each node is visited exactly once, and for each node, we process its neighbors (edges).
     - The total number of edges across all nodes is `E`, and the total number of nodes is `n`. Hence, the time complexity for BFS is **O(n + E)**.
   
   - **Space Complexity**:  
     - The space complexity is determined by the queue and the `vis` array. The queue can store at most `n` nodes at a time, and the `vis` array takes `O(n)` space to store the visited status of each node.
     - Therefore, the space complexity is **O(n)**.

---

#### 2. **`dfs(int start, vector<vector<int>>& graph, vector<int>& vis)`**
   - **Time Complexity**:  
     - The DFS function recursively visits each node and explores its neighbors. Similar to BFS, each node is visited exactly once, and for each node, we visit its neighbors (edges).
     - The time complexity is **O(n + E)**, where `n` is the number of nodes and `E` is the number of edges in the graph, since we visit each node and edge at most once.

   - **Space Complexity**:  
     - The space complexity is determined by the `vis` array (which takes `O(n)` space), and the recursion stack. In the worst case, the recursion depth could go up to `n` if the graph is a straight line or tree.
     - Therefore, the space complexity is **O(n)** due to the recursion stack and the `vis` array.

---

#### 3. **`getGraph(vector<vector<int>>& isConnected, vector<vector<int>>& graph)`**
   - **Time Complexity**:  
     - This function iterates over all pairs of nodes `(i, j)` to check if they are connected (i.e., `isConnected[i][j] == 1`), and for each connected pair, it adds an undirected edge in the `graph`.  
     - There are `n * n` possible pairs of nodes, so this part takes **O(n^2)** time.
   
   - **Space Complexity**:  
     - The space complexity is determined by the size of the `graph` array, which stores adjacency lists. There are `n` nodes, and each node can have up to `n` neighbors. Hence, the space complexity for the adjacency list is **O(n^2)** in the worst case.
     - The space complexity is **O(n^2)**.

---

#### 4. **`findCircleNum(vector<vector<int>>& isConnected)`**
   - **Time Complexity**:  
     - This function starts by calling `getGraph`, which takes **O(n^2)** time to build the graph.
     - After that, it calls `bfs` for each unvisited node. In the worst case, this loop will call BFS for each of the `n` nodes. Each BFS call has a time complexity of **O(n + E)**.
     - In the worst case, each call to `bfs` processes all the nodes and edges in the graph.
     - Therefore, the overall time complexity is **O(n^2 + n * (n + E))**. Since **n^2** is the upper bound for the number of edges in a complete graph, this simplifies to **O(n^2)**.

   - **Space Complexity**:  
     - The space complexity is dominated by the space used to store the graph and the `vis` array.
     - The graph requires **O(n^2)** space in the worst case (if the graph is fully connected).
     - The `vis` array requires **O(n)** space.
     - Therefore, the overall space complexity is **O(n^2)**.

---

### Final Summary

- **Time Complexity**: The overall time complexity of the code is **O(n^2)**, where `n` is the number of nodes. This comes from:
  - Building the graph with **O(n^2)**.
  - Running BFS/DFS for each node, which in the worst case processes all nodes and edges.

- **Space Complexity**: The overall space complexity is **O(n^2)**, mainly due to the storage of the graph (adjacency list), which can have up to **O(n^2)** space in the worst case (for a complete graph). The `vis` array also takes **O(n)** space, but it does not affect the overall complexity.


##########################################################################################

#include <bits/stdc++.h>
using namespace std;

class Solution {
  private: 
    // dfs traversal function 
    void dfs(int node, vector<int> adjLs[], int vis[]) {
        // mark the more as visited
        vis[node] = 1; 
        for(auto it: adjLs[node]) {
            if(!vis[it]) {
                dfs(it, adjLs, vis); 
            }
        }
    }
  public:
    int numProvinces(vector<vector<int>> adj, int V) {
        vector<int> adjLs[V]; 
        
        // to change adjacency matrix to list 
        for(int i = 0;i<V;i++) {
            for(int j = 0;j<V;j++) {
                // self nodes are not considered
                if(adj[i][j] == 1 && i != j) {
                    adjLs[i].push_back(j); 
                    adjLs[j].push_back(i); 
                }
            }
        }
        int vis[V] = {0}; 
        int cnt = 0; 
        for(int i = 0;i<V;i++) {
            // if the node is not visited
            if(!vis[i]) {
                // counter to count the number of provinces 
                cnt++;
               dfs(i, adjLs, vis); 
            }
        }
        return cnt; 
        
    }
};

int main() {
    
    vector<vector<int>> adj
    {
        {1, 0, 1},
        {0, 1, 0},
        {1, 0, 1}
    };

        
    Solution ob;
    cout << ob.numProvinces(adj,3) << endl;
        
    return 0;
}
Output: 2

Time Complexity: O(N) + O(V+2E), Where O(N) is for outer loop and inner loop runs in total a single DFS over entire graph, and we know DFS takes a time of O(V+2E). 

Space Complexity: O(N) + O(N),Space for recursion stack space and visited array.