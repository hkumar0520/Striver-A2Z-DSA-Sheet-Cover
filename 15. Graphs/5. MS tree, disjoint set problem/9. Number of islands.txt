
https://www.naukri.com/code360/problems/number-of-islands-ii_1266048?leftPanelTabValue=SUBMISSION

#include<bits/stdc++.h>

class DisjointSet{
	vector<int> parent, rank, size;
	public:

	DisjointSet(int n)
	{
		parent.resize(n, 0);
		rank.resize(n, 0);
		size.resize(n, 1);
		for(int i=0; i<n; i++)
			parent[i] = i;
	}

	int findParent(int x)
	{
		if(x == parent[x])
			return x;

		return parent[x] = findParent(parent[x]);
	}

    void unionByRank(int u, int v)
    {
        int ulp_u = findParent(u);
        int ulp_v = findParent(v);
        if(ulp_u == ulp_v)  return ;

        if( rank[ulp_u] < rank[ulp_v]){
            parent[ulp_u] = ulp_v;
        }
        else if( rank[ulp_v] < rank[ulp_u]){
            parent[ulp_v] = ulp_u;
        }
        else{
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }
    
    void unionBySize(int u, int v)
    {
        int ulp_u = findParent(u);
        int ulp_v = findParent(v);
        if(ulp_u == ulp_v)  return ;

        if( size[ulp_u] < size[ulp_v]){
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }

    int getSize(int x){
        return size[x];
    }
};

vector<int> numOfIslandsII(int rowSize, int colSize, vector<vector<int>> &q){
	// Write your code here.
	int totalSize = rowSize*colSize;

	DisjointSet ds(totalSize);

	// left , up, right, down;
	vector<int> xCordinates = { 0, -1, 0, 1};
	vector<int> yCordinates = { -1, 0, 1, 0};

	// for keeping track of vis coordinates
	unordered_set<int> vis;

	vector<int> ans;

	// O(q)
	for(int i = 0; i<q.size(); i++)
	{
		// current query
		int x = q[i][0], y = q[i][1];
		int currNum = x*colSize + y;

		// keep track of which numbers are visited
		vis.insert( currNum );

		// O(4)
		for(int k = 0; k<4; k++)
		{
			int nx = x + xCordinates[k];
			int ny = y + yCordinates[k];
			if(nx>=0 && ny>=0 && nx<rowSize && ny<colSize){
				int adjNum = nx*colSize + ny;

				if(vis.find( adjNum ) != vis.end())
					ds.unionByRank( adjNum, currNum);     // O(4*a)
			}
		}

		int noOfIslands = 0;
		// 0(n)
		for(auto it: vis){
			if( it == ds.findParent(it))
				noOfIslands++;
		}
		ans.push_back(noOfIslands);
	}
	return ans;
}


time complexity = q*4*4@
space complexity = 3n
{
	n = parent,
	n = rank,
	n = size 
}
