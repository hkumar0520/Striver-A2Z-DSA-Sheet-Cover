
// simple queue, 687ms

class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        
        vector<int> dist(n, INT_MAX);
        dist[src] = 0;

        queue<vector<int>> qtraverse;
        
        // 0-step, 1-price, 2-src
        qtraverse.push({0, 0, src});

        while(!qtraverse.empty())
        {
            vector<int> currCity = qtraverse.front();
            qtraverse.pop();

            int  stopNo = currCity[0], cost = currCity[1], stopCity = currCity[2];

            // k+1 th stop is destination, means no going forward
            if(stopNo == (k+1))
                continue;

            for(vector<int> edge: flights)
            {
                int fromCity = edge[0], toCity = edge[1], costTravelling = edge[2];
                if(fromCity == stopCity && (dist[toCity] > cost + costTravelling))
                {
                    dist[toCity] = cost + costTravelling;
                    qtraverse.push({ stopNo+1, dist[toCity], toCity});
                }
            }
        }
        return dist[dst] == INT_MAX? -1: dist[dst];
    }
};


#####################################################################################

//12ms, 2ms, 0ms 

class Solution {
public:
    void getGraph(vector<vector<pair<int,int>>>& graph, vector<vector<int>>& flights)
    {
        for(auto edge: flights)
        {
            int fromCity = edge[0], toCity = edge[1], cost = edge[2];
            graph[fromCity].push_back({toCity, cost});
        }
    }
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        
        vector<vector<pair<int,int>>> graph(n);
        getGraph(graph, flights);

        vector<int> dist(n, INT_MAX);
        dist[src] = 0;

        queue<vector<int>> qtraverse;
        
        // 0-step, 1-price, 2-src
        qtraverse.push({0, 0, src});

        while(!qtraverse.empty())
        {
            vector<int> currCity = qtraverse.front();
            qtraverse.pop();

            int  stopNo = currCity[0], cost = currCity[1], stopCity = currCity[2];

            // k+1 th stop is destination, means no going forward
            if(stopNo == (k+1))
                continue;

            for(pair<int,int> curr: graph[stopCity])
            {
                int toCity = curr.first, costTravelling = curr.second;
                if(dist[toCity] > cost + costTravelling)
                {
                    dist[toCity] = cost + costTravelling;
                    qtraverse.push({ stopNo+1, dist[toCity], toCity});
                }
            }
        }
        return dist[dst] == INT_MAX? -1: dist[dst];
    }
};



Let's break down the time and space complexity of the code step by step:

### Code Description:
This code implements a solution to find the cheapest price from a source city to a destination city with at most `k` stops. It uses a graph-based approach with a breadth-first search (BFS) strategy and a queue to traverse the graph level by level.

### 1. `getGraph` Function:
```cpp
void getGraph(vector<vector<pair<int,int>>>& graph, vector<vector<int>>& flights)
```
This function builds the graph where each city is represented as a node and its outgoing flights are stored as edges. Each edge is a pair containing the destination city and the travel cost.

- **Time Complexity**:  
   - The input `flights` has `m` entries, where each entry represents a flight with a source city, destination city, and cost. The loop iterates over all the flights.
   - **Time complexity**: O(m), where `m` is the number of flights.
  
- **Space Complexity**:  
   - The graph stores `n` cities, and each city has a list of outgoing edges. In the worst case, all cities might be connected to each other.
   - **Space complexity**: O(n + m), where `n` is the number of cities and `m` is the number of flights.

### 2. `findCheapestPrice` Function:
```cpp
int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k)
```
- **Input Parameters**:
   - `n`: number of cities.
   - `flights`: a list of all the flights.
   - `src`: the source city.
   - `dst`: the destination city.
   - `k`: the maximum number of stops.

This function uses a BFS approach with a queue (`qtraverse`) to explore all possible routes, where each entry in the queue consists of:
   - `stopNo`: The number of stops taken so far.
   - `cost`: The accumulated cost so far.
   - `stopCity`: The current city being visited.

- **Time Complexity**:  
   The BFS explores each city, and for each city, it looks at all the outgoing flights (edges). The number of cities is `n` and the number of flights is `m`. In the worst case, the algorithm explores all the cities and all the flights. Additionally, for each city, it can have up to `k+1` levels of stops in the queue.
   - The queue may contain at most `O(n * (k+1))` entries (since at most `k+1` stops are allowed).
   - For each entry in the queue, the algorithm explores all outgoing flights (edges) from the current city, and the number of outgoing flights for a city is proportional to the number of flights `m`.
   - **Time complexity**: O((k+1) * m), where `k` is the maximum number of stops and `m` is the number of flights. Since the algorithm may need to traverse all flights and cities with up to `k+1` stops, the complexity is O((k+1) * m).

- **Space Complexity**:  
   - The space used by the graph is O(n + m) (since each city can have multiple outgoing flights).
   - The queue `qtraverse` can hold up to O(n * (k+1)) entries at a time.
   - The `dist` array holds the shortest cost to reach each city, which requires O(n) space.
   - **Space complexity**: O(n + m + n * (k+1)) â‰ˆ O(n * (k+1) + m) in the worst case.

### Overall Time and Space Complexity:

- **Time Complexity**: O((k+1) * m), where `k` is the maximum number of stops and `m` is the number of flights.
  
- **Space Complexity**: O(n * (k+1) + m), where `n` is the number of cities, `k` is the maximum number of stops, and `m` is the number of flights.





#######################################################################################

TLE now 

class Solution {
public:
    void getGraph(vector<vector<pair<int,int>>>& graph, vector<vector<int>>& flights)
    {
        for(auto edge: flights)
        {
            int fromCity = edge[0], toCity = edge[1], cost = edge[2];
            graph[fromCity].push_back({toCity, cost});
        }
    }
    struct CustomComparator{
        bool operator()(vector<int> a,vector<int> b){
            return a[1]>b[1];
        }
    };
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        
        vector<vector<pair<int,int>>> graph(n);
        getGraph(graph, flights);

        vector<int> dist(n, INT_MAX);
        dist[src] = 0;

        // queue<vector<int>> qtraverse;
        priority_queue< vector<int>, vector<vector<int>>,
                        CustomComparator > qtraverse;
        
        // 0-step, 1-price, 2-src
        qtraverse.push({0, 0, src});

        while(!qtraverse.empty())
        {
            vector<int> currCity = qtraverse.top();
            qtraverse.pop();

            int  stopNo = currCity[0], cost = currCity[1], stopCity = currCity[2];

            if(stopCity == dst)
                return cost;
            // k+1 th stop is destination, means no going forward
            if(stopNo == (k+1))
                continue;

            for(pair<int,int> curr: graph[stopCity])
            {
                int toCity = curr.first, costTravelling = curr.second;
                // if(dist[toCity] > cost + costTravelling)
                // {
                    // dist[toCity] = cost + costTravelling;
                    qtraverse.push({ stopNo+1, cost + costTravelling, toCity});
                // }
            }
        }
        return dist[dst] == INT_MAX? -1: dist[dst];
    }
};