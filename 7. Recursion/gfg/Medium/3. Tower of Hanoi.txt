

Intuition

The **Tower of Hanoi** is a classic problem in recursion and problem-solving. Here's an intuitive breakdown of how it works:

---

### **Problem Statement**
You have three rods and \( n \) disks of different sizes. The disks are initially stacked on one rod in decreasing order of size (largest at the bottom, smallest at the top). The goal is to move all the disks to another rod, following these rules:
1. Only one disk can be moved at a time.
2. A disk can only be placed on top of a larger disk or on an empty rod.

---

### **Key Intuition**
The problem is inherently recursive because:
1. To move \( n \) disks, you first need to move \( n-1 \) disks to a temporary rod.
2. Then, move the largest disk to the destination rod.
3. Finally, move the \( n-1 \) disks from the temporary rod to the destination rod.

The recursive structure arises because the same process is applied repeatedly for \( n-1 \), \( n-2 \), and so on.

---

### **Breaking It Down**
Letâ€™s consider \( n = 3 \) as an example:
- **Step 1**: Move the top 2 disks from the source rod (A) to the auxiliary rod (B), using the destination rod (C) as a helper.
- **Step 2**: Move the largest disk from the source rod (A) to the destination rod (C).
- **Step 3**: Move the 2 disks from the auxiliary rod (B) to the destination rod (C), using the source rod (A) as a helper.

#### **Recursive Insight**
For \( n \) disks:
1. Solve the subproblem of moving \( n-1 \) disks from the source to the auxiliary rod.
2. Move the \( n \)-th (largest) disk directly to the destination rod.
3. Solve the subproblem of moving \( n-1 \) disks from the auxiliary rod to the destination rod.

---

### **Visualization**
For \( n = 3 \):
1. Initially:
   - A: [3, 2, 1] (source)
   - B: [] (auxiliary)
   - C: [] (destination)

2. After Step 1:
   - A: [3]
   - B: [2, 1]
   - C: []

3. After Step 2:
   - A: []
   - B: [2, 1]
   - C: [3]

4. After Step 3:
   - A: []
   - B: []
   - C: [3, 2, 1]

---

### **Mathematical Insight**
The minimum number of moves required to solve the Tower of Hanoi with \( n \) disks is:
\[
T(n) = 2^n - 1
\]
This arises because:
1. Moving \( n-1 \) disks requires \( T(n-1) \) moves.
2. Moving the largest disk requires 1 move.
3. Moving the \( n-1 \) disks again requires \( T(n-1) \) moves.

Thus:
\[
T(n) = 2 \cdot T(n-1) + 1
\]

---

### **Key Takeaways**
1. **Recursive Nature**: The problem boils down to solving smaller subproblems of the same type.
2. **Divide and Conquer**: Break the problem into smaller steps, focusing on moving smaller disks first.
3. **Exponential Growth**: The number of moves grows exponentially with the number of disks.

By practicing with smaller \( n \), the recursive structure and the pattern of moves become clear.





class Solution {
  public:
    // You need to complete this function

    int towerOfHanoi(int n, int from, int to, int aux) {
        // Your code here
        if(n <= 1)
            return n;
            
        int moveOne = towerOfHanoi(n-1, from, aux, to);
        int moveTwo = towerOfHanoi(n-1, aux, to, from);
        
        return moveOne + moveTwo +1;
    }
};


### **Time and Space Complexity Analysis**

Let's analyze the given **Tower of Hanoi** recursive function:

---

### **Code Walkthrough**
1. The function `towerOfHanoi` computes the number of moves required to transfer \( n \) disks from the `from` rod to the `to` rod, using the `aux` rod as a helper.
2. The base case is \( n \leq 1 \), where the function directly returns \( n \) (1 move for \( n = 1 \), 0 moves for \( n = 0 \)).
3. For \( n > 1 \), the function makes two recursive calls:
   - `towerOfHanoi(n-1, from, aux, to)` for moving \( n-1 \) disks to the auxiliary rod.
   - `towerOfHanoi(n-1, aux, to, from)` for moving \( n-1 \) disks from the auxiliary rod to the destination rod.
4. Finally, it adds \( 1 \) for the move of the largest disk.

---

### **Time Complexity**
The recurrence relation for this function is:
\[
T(n) = 2 \cdot T(n-1) + 1
\]
This is the standard recurrence for the Tower of Hanoi problem. Solving it:
\[
T(n) = 2^n - 1
\]

Thus, the **time complexity** is:
\[
O(2^n)
\]

---

### **Space Complexity**
1. **Recursive Call Stack**:
   - The depth of recursion is \( n \), as each call reduces \( n \) by 1.
   - Space required for the call stack is \( O(n) \).

2. **No Additional Space**:
   - The function does not use any additional data structures or memory apart from the recursion stack.

Thus, the **space complexity** is:
\[
O(n)
\]

---

### **Final Complexity**
- **Time Complexity**: \( O(2^n) \)
- **Space Complexity**: \( O(n) \)




###############################################################################
