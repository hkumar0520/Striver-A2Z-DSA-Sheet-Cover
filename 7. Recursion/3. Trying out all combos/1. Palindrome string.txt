


class Solution {
public:

    bool isPaldinrome(string str, int start, int end){
        while(start<= end){
            if(str[start++] != str[end--])
                return false;
        }
        return true;
    }

    void backTrack(int ind, string str, vector<string>& path,
            vector<vector<string>>& ans)
    {
        if(ind == str.size()){
            ans.push_back(path);
            return;
        }

        for(int i = ind; i<str.size(); i++){
            if(isPaldinrome(str, ind, i)){
                path.push_back(str.substr(ind, i-ind+1));
                backTrack(i+1, str, path, ans);
                path.pop_back();
            }
        }
    }
    vector<vector<string>> partition(string s) {
        vector<string> path;
        vector<vector<string>> ans;

        backTrack(0, s, path, ans);
        return ans;
    }
};

Time Complexity: O( (2^n) *k*(n/2) )

Reason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.

Space Complexity: O(k * x)

Reason: The space complexity can vary depending upon the length of the answer. k is the average length of the list of palindromes and if we have x such list of palindromes in our final answer. The depth of the recursion tree is n, so the auxiliary space required is equal to the O(n).
k = n, x = 2^n



### Time Complexity:

Letâ€™s break down the time complexity based on the code.

#### 1. **isPalindrome Function:**

The function `isPalindrome(str, start, end)` checks if a given substring of `str` is a palindrome. The time complexity of this function is \( O(n) \), where `n` is the length of the substring being checked. Specifically, it compares characters starting from `start` and `end` indices, iterating over the substring.

#### 2. **backTrack Function:**

The `backTrack` function is the core recursive function that tries all possible palindromic partitions. The function uses a backtracking approach:

- For each position `ind` in the string `str`, it attempts to form palindromes from `ind` to all subsequent positions (`i` from `ind` to `str.size()-1`).
- For each substring `str[ind...i]`, it checks if it's a palindrome (calls `isPalindrome`).
- If it is a palindrome, the function recurses to find further palindromes starting from the next index (`i+1`).

**Number of recursive calls:**
- There are \( O(2^n) \) possible partitions of the string (since each character can either start a new palindrome substring or not).
- In the worst case, we explore all possible partitions.

Each recursive call involves iterating over the string from `ind` to `str.size()-1`, meaning there are \( O(n) \) iterations in the worst case for each call to `backTrack`.

#### 3. **Overall Time Complexity:**

In the worst case:
- For each of the \( O(2^n) \) recursive calls, we might have to check all possible substrings (each of which takes \( O(n) \) time for the palindrome check).
- Therefore, the total time complexity is:

\[
O(2^n \cdot n)
\]

This comes from \( O(2^n) \) recursive calls and \( O(n) \) time for each palindrome check.

### Space Complexity:

#### 1. **Space Used by Recursion (Call Stack):**

The depth of the recursion is at most \( O(n) \), where `n` is the length of the input string. This is because we are making recursive calls starting from index `ind` and the recursion tree will have a depth equal to the length of the string.

Thus, the space complexity due to recursion is:

\[
O(n)
\]

#### 2. **Space Used by the Result (Answer Storage):**

The result is stored in `ans`, which contains all possible partitions of the string. Each partition can have up to \( O(n) \) substrings, and in the worst case, there are \( O(2^n) \) partitions.

Therefore, the space complexity required to store the results is:

\[
O(2^n \cdot n)
\]

This comes from \( O(2^n) \) possible partitions, with each partition containing up to \( O(n) \) substrings.

#### 3. **Space Complexity for Storing Path:**

At each recursive call, we store the current palindromic partition in `path`, which can contain at most \( O(n) \) substrings. Since we store the path during recursion and then backtrack, the space complexity due to the path storage is \( O(n) \).

### Total Space Complexity:

Combining all components:

\[
O(n) \, \text{(recursion stack)} + O(2^n \cdot n) \, \text{(answer storage)} = O(2^n \cdot n)
\]

### Summary:

- **Time Complexity:** \( O(2^n \cdot n) \)
- **Space Complexity:** \( O(2^n \cdot n) \)


