
// word boggle of trie is hard part of this 


class Solution {
public:
    bool backTrack(pair<int,int> cordinates,int idx, string word
    , vector<vector<char>>& board)
    {
        int xCordinate = cordinates.first, yCordinate = cordinates.second;
        int rowSize = board.size(), colSize = board[0].size();

        if(idx == word.size())
            return true;

        if(xCordinate<0 || yCordinate<0 || xCordinate == rowSize ||
          yCordinate == colSize || board[xCordinate][yCordinate] != word[idx]
          || board[xCordinate][yCordinate] == '0')
            return false;

        char ch = board[xCordinate][yCordinate];
        board[xCordinate][yCordinate] = '0';

        int a[4] = {-1, 0, 1, 0};
        int b[4] = {0, 1, 0, -1};

        for(int i = 0; i<4; i++){
            int xNew = xCordinate + a[i];
            int yNew = yCordinate + b[i];
            if(backTrack({ xNew, yNew}, idx+1, word, board))
                return true;
        }

        board[xCordinate][yCordinate] = ch;
        return false;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[0].size(); j++){
                if(board[i][j] == word[0]){
                    if(backTrack({i, j}, 0, word, board))
                        return true;
                }
            }
        }
        return false;
    }
    
};


To analyze the time and space complexity of the given code, let's break it down step by step:

### Time Complexity:

The algorithm uses Depth-First Search (DFS) through backtracking to explore the board for the given word.

1. **Backtracking Recursion (DFS):**
   - The function `backTrack` is recursively called to explore all possible paths starting from a given cell. For each cell, it checks 4 possible directions (up, down, left, right).
   - In the worst case, every cell in the grid may need to be visited once for every character in the word. Therefore, at most, we will explore all cells for each character in the word.

2. **Outer Loop (in `exist` function):**
   - The function `exist` iterates over each cell in the grid to find the starting point that matches the first character of the word. This takes `O(m * n)` time where `m` is the number of rows and `n` is the number of columns in the board.

3. **Backtrack Function Calls:**
   - Once a match for the first character is found, the `backTrack` function starts exploring in all four directions. For each recursive call, the search continues to the next character in the word. This exploration involves visiting each neighboring cell, potentially leading to a search that involves all `m * n` cells for each character of the word.

4. **Worst-Case Scenario:**
   - In the worst case, for each of the `m * n` cells, the algorithm explores all `m * n` neighboring cells for each character in the word. Therefore, the worst-case time complexity is `O(m * n * 4^L)`, where:
     - `m * n` is the number of cells in the board.
     - `L` is the length of the word.
     - `4^L` represents the branching factor as each character of the word can branch out to 4 possible neighbors.

   - **Time Complexity: O(m * n * 4^L)**

### Space Complexity:

1. **Auxiliary Space for Recursion:**
   - The space used by the recursive stack is proportional to the maximum depth of recursion, which corresponds to the length of the word `L`. In the worst case, the recursion depth could be equal to the length of the word, so the space complexity for recursion is `O(L)`.

2. **Board Modifications:**
   - The algorithm modifies the board in place by marking visited cells with '0'. It does not use any additional data structures like an auxiliary visited matrix. Therefore, no extra space is required for tracking visited cells, apart from the board itself.

3. **Total Space Complexity:**
   - The space complexity is primarily determined by the recursive call stack, which is `O(L)` where `L` is the length of the word.

   - **Space Complexity: O(L)**

### Summary:
- **Time Complexity:** `O(m * n * 4^L)` where `m` is the number of rows, `n` is the number of columns, and `L` is the length of the word.
- **Space Complexity:** `O(L)` due to the recursive call stack.







######################################################################################






class Solution {
public:
    bool backTrack(int x, int y, int idx, string& word, vector<vector<char>>& board) {
        int m = board.size(), n = board[0].size();

        // Base cases: If the index is out of bounds or the character doesn't match, return false.
        if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] != word[idx])
            return false;

        // If we've matched all characters, return true
        if (idx == word.size() - 1)
            return true;

        // Save the current character and mark this cell as visited by setting it to '0'
        char temp = board[x][y];
        board[x][y] = '0';

        // Explore in all four directions
        int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (auto& dir : directions) {
            int newX = x + dir[0], newY = y + dir[1];
            if (backTrack(newX, newY, idx + 1, word, board))
                return true;
        }

        // Restore the original character
        board[x][y] = temp;

        return false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();

        // Check character frequency: if board doesn't have enough of any character from word, return false early.
        unordered_map<char, int> freqBoard, freqWord;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                freqBoard[board[i][j]]++;
            }
        }
        for (char c : word) {
            freqWord[c]++;
        }

        // Early pruning: if any character in word is not present enough times in board, return false.
        for (const auto& [c, count] : freqWord) {
            if (freqBoard[c] < count) {
                return false;
            }
        }

        // Start DFS from each cell that matches the first character of word
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (board[i][j] == word[0]) {
                    if (backTrack(i, j, 0, word, board))
                        return true;
                }
            }
        }

        return false;
    }
};



###############################################################################################



write in different way

class Solution {
public:
    bool backTrack(pair<int,int> cordinates,int idx, string word
    , vector<vector<char>>& board)
    {
        int xCordinate = cordinates.first, yCordinate = cordinates.second;
        int rowSize = board.size(), colSize = board[0].size();

        if(idx == word.size())
            return true;

        int a[4] = {-1, 0, 1, 0};
        int b[4] = {0, 1, 0, -1};

        for(int i = 0; i<4; i++){
            int xNew = xCordinate + a[i];
            int yNew = yCordinate + b[i];
            if(xNew >=0 && yNew>=0 && xNew<rowSize && yNew<colSize && board[xNew][yNew] == word[idx]){
                char ch = board[xNew][yNew];
                board[xNew][yNew] = '0';

                if(backTrack({ xNew, yNew}, idx+1, word, board))
                    return true;

                board[xNew][yNew] = ch;
            }
        }

        return false;
    }
    
    bool exist(vector<vector<char>>& board, string word) {


        int m = board.size(), n = board[0].size();

        // Check character frequency: if board doesn't have enough of any character from word, return false early.
        unordered_map<char, int> freqBoard, freqWord;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                freqBoard[board[i][j]]++;
            }
        }
        for (char c : word) {
            freqWord[c]++;
        }

        // Early pruning: if any character in word is not present enough times in board, return false.
        for (const auto& [c, count] : freqWord) {
            if (freqBoard[c] < count) {
                return false;
            }
        }



        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[0].size(); j++){
                if(board[i][j] == word[0]){
                    char ch = board[i][j];
                    board[i][j] = '0';

                    if(backTrack({i, j}, 1, word, board))
                        return true;
                    
                    board[i][j] = ch;
                }
            }
        }
        return false;
    }
    
};







