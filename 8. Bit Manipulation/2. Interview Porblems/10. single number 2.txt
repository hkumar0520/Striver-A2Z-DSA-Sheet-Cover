
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        map<int,int> mp;
        for(int num: nums)
            mp[num]++;

        for(auto res: mp){
            if(res.second == 1)
                return res.first;
        }

        return -1;
    }
};

TC: O(nlogm){
    m = (n/3)+1
}
SC: O(1)


#############################################################################

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0;
        for(int i = 0; i<32; i++){
            
            int cnt = 0;
            for(int j = 0; j<nums.size(); j++)
                 cnt += (nums[j] & (1<<i)) ? 1 : 0;

            if(cnt%3 == 1)
                result = result | (1<<i);
        }
        return result;
    }
};

TC: O(n*32)
SC: O(1)


#############################################################################

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int i, len = nums.size();
        for(i = 1; i<len; i+= 3){
            if(nums[i] != nums[i-1])
                return nums[i-1];
        }

        return nums[len-1];
    }
};

TC: O(nlogn)
SC: O(1)


#############################################################################

// concept of bucket

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ones = 0, twos = 0;
        for(int num: nums){
            // not in twos , add in ones
            ones = ( ones ^ num) & ~(twos);

            // not in ones, add in twos
            twos = ( twos ^ num) & ~(ones);
        }
        return ones;
    }
};

TC: O(n)
SC: O(1)



