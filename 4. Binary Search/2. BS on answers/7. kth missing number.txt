
1. brute force (n, 1)
2. optimal (logn, 1)


int missingK(vector < int > vec, int n, int k) {
    // Write your code here.
    for(auto u: vec)
    {
        if(u<=k)
            k++;
        else
            break;
    }
    return k;
}

TC: O(n)
SC: O(1)

################################################################################################


int missingK(vector < int > vec, int n, int k) {
    // Write your code here.
    int i = 0, j = n-1;
    while(i<=j)
    {
        int mid = (i+j)/2;
        int missing = vec[mid] - (mid+1);
        if(missing<k)
            i = mid+1;
        else
            j = mid-1;
    }
    // return j+1+k;
    return i+k;
}


TC: O(logn, 1)
SC: O(1)



mssing at last is J <= i;

missing no = arr[j] + (k - (arr[j] - (j+1) ) )
           = k+j+1;
           or (k+i)


