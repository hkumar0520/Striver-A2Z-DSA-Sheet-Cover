

// brute force

class Solution {
  public:
  
    
    int kthElement(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<int> arr;
        int num1Len = nums1.size(), num2Len = nums2.size();
        int i = 0, j = 0;
        while( i<num1Len && j<num2Len){
            if(nums1[i] <= nums2[j]){
                arr.push_back(nums1[i]);
                i++;
            }
            else if(nums2[j] <= nums1[i]){
                arr.push_back(nums2[j]);
                j++;
            }
        }
        while(i<num1Len)
            arr.push_back(nums1[i++]);

        while(j<num2Len)
            arr.push_back(nums2[j++]);

        return arr[k-1];
    }
};

TC: O(n+m)
SC: O(n+m)


########################################################################

class Solution {
    
  public:
    int kthElement(vector<int>& nums1, vector<int>& nums2, int k) {
        // code here
        
        int num1Len = nums1.size(), num2Len = nums2.size();
        int i = 0, j = 0, firstElement = -1, secondElement = -1;
        int cntLenArr = 0;

        while( i<num1Len && j<num2Len){
            if(nums1[i] <= nums2[j]){
                if(cntLenArr == (k-1))  return nums1[i];
                
                cntLenArr++;
                i++;
            }
            else{
                if(cntLenArr == (k-1))  return nums2[j];

                cntLenArr++;
                j++;
            }
        }
        while(i < num1Len){
                if(cntLenArr == (k-1))  return nums1[i];
                
                cntLenArr++;
                i++;

        }

        while(j<num2Len){
                if(cntLenArr == (k-1))  return nums2[j];

                cntLenArr++;
                j++;

        }

        return -1;
    }
};


TC: O(n+m)
SC: O(1)


###########################################################################################


for low handling

finally, the mystery of why low and high needs to be corrected for this solution?
Let's take an example, m = 3, n = 10, k = 12
If we keep low = 0, and high = 3
then mid1 = 1;
low = 0 means we don't pick any element from the first array, and now the remaining elements need to be picked from the second array.
mid2 = (k - mid1) = 12 - 1 = 11 ???? but there are only 10 elements in the second array
Hence we can't start our search when we pick no elements from the first array.
So our low must be max(k - n, 0) [no of elements  at least need to pick for 1st array]
Similarly, for high, we have to reduce the search space such that it can handle low K values.

Note: this issue doesn't occur in the median problem because we guaranteed to split the search space in half every time.


for high handling

if n1 > k, we do not need to pick k+1 element , so that's why
high = min(n1, k) , we are picking max k elements
if n1 <k , we need to pick n1 element only from first array




class Solution {
    
  public:
    int kthElement(vector<int>& nums1, vector<int>& nums2, int k) {
        // code here
        
        int nums1Len = nums1.size(), nums2Len = nums2.size();
        if(nums1Len > nums2Len)
            return kthElement(nums2, nums1, k);

        int low = max(0, k-nums2Len), high = min(k, nums1Len);
        // in left we are taking more elements in case of overall size = odd
        int left = k;
        while(low <= high){
            int mid1 = (low + high)/2;
            int mid2 = left - mid1;
            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;
            
            if( mid1 < nums1Len)    r1 = nums1[mid1];
            if( mid2 < nums2Len)    r2 = nums2[mid2];

            if( (mid1 - 1) >=0)     l1 = nums1[mid1-1];
            if( (mid2 - 1) >=0)     l2 = nums2[mid2-1];

            if( l1 <= r2 && l2 <= r1){
                return max(l1, l2);
            }
            else if(l1 > r2)
                high = mid1-1;
            else  // else if(l2 > r1)
                low = mid1+1;
        }
        
        return 0;
    }
};



TC: O(log(min(m,n)))
SC: O(1)

