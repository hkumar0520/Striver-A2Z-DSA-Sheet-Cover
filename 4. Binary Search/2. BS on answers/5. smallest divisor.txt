


int findsum(vector<int>& arr, int limit, int mid)
{
	int sum = 0;
	for(auto u: arr)
		sum += ceil((double)u/(double)mid);

	return sum;
}
int smallestDivisor(vector<int>& arr, int limit)
{
	// Write your code here.
	int maxx = -1;
	for(auto u: arr)
		maxx = max(u, maxx);

	int lo = 1, hi = maxx;
	while(lo <= hi)
	{
		int mid = (lo + hi)/2;
		int sum = findsum(arr, limit, mid);
		if(sum <= limit)
			hi = mid-1;
		else
			lo = mid+1;

	}
	return lo;
}



#######################################################################



class Solution {
public:
    
    int calculateDivisor(vector<int>& nums, int divisor, int threshold) {
        int ans = 0;
        for(int num: nums)
            ans += ceil((double)num/(double)divisor);

        return ( ans <= threshold );
    }
    int smallestDivisor(vector<int>& nums, int threshold) {
        
        int maxNum = INT_MIN;
        for(int num: nums)
            maxNum = max(maxNum, num);

        // i = 1(condition  not satisfy), j = maxNum(condition satisfy)
        // after BS, i (condition  satisfy), j ( condition not satisfy)
        int i = 1, j = maxNum;
        while( i <= j){
            int mid = (i + j)/2;

            bool isPossible = calculateDivisor(nums, mid, threshold);
            if( isPossible )
                j = mid-1;
            else
                i = mid+1;
        }
        return i;
    }
};



Let's analyze the **time and space complexity** of the given code.

---

## **Time Complexity Analysis**
The code is solving the **"Find the Smallest Divisor Given a Threshold"** problem using **binary search on the answer**. Let's break it down step by step.

### **1. Finding the Maximum Element**
- The code iterates through `nums` once to determine the maximum value (`maxNum`).
- This takes **O(N)** time.

### **2. Binary Search on the Divisor (`d`)**
- The search space is from `1` to `maxNum`, which is at most **O(M)** (where \( M \) is the largest element in `nums`).
- Binary search runs in **O(log M)** time.

### **3. Checking Feasibility (`calculateDivisor` function)**
- For each `mid`, the function **checks** whether it's possible to divide all numbers and keep the sum within `threshold`.
- This requires iterating over `nums`, which takes **O(N)** time.
- Since this function is called in every iteration of the binary search, the worst-case number of calls is **O(log M)**.

### **Total Time Complexity**
Since we perform **O(N)** work in each of the **O(log M)** binary search iterations, the total time complexity is:

\[
O(N + N \log M) = O(N \log M)
\]

---

## **Space Complexity Analysis**
1. The algorithm only uses a few integer variables (`i`, `j`, `mid`, `maxNum`).
2. No extra data structures are used.
3. The `calculateDivisor` function also operates in **O(1)** extra space.

Thus, the space complexity is:

\[
O(1)
\]

---

## **Final Complexity**
- **Time Complexity:** \( O(N \log M) \), where \( N \) is the size of `nums` and \( M \) is the largest element in `nums`.  
- **Space Complexity:** \( O(1) \).  

This is an efficient approach leveraging **binary search on the answer** instead of brute force. ðŸš€

