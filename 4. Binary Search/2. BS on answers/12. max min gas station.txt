

time limit exceed

double minimiseMaxDistance(vector<int> &arr, int k){
	// Write your code here.	
	int n = arr.size();
	vector<int> howMany(n-1, 0);
	for(int i = 1 ; i<=k; i++){

		long double maxLen = -1;
		int index = -1;

		for(int j = 0; j<n-1;j++){
			long double sectionLen = (long double)(arr[j+1] - arr[j])/ (long double)(howMany[j] + 1);
			
			if(sectionLen > maxLen)
			{
				maxLen = sectionLen;
				index = j;
			}
		}
		howMany[index]++;
	}

	long double ans = -1;
	for(int i = 0; i<n-1; i++){
		long double sectionLen = (long double)(arr[i+1] - arr[i])/ (long double)(howMany[i] + 1);
		ans = max(ans, sectionLen);	
	}
	return ans;
}


TC: O(k*n)
SC: O(n)

##################################################################################################


#include<bits/stdc++.h>

double minimiseMaxDistance(vector<int> &arr, int k){
	// Write your code here.	
	int n = arr.size();
	vector<int> howMany(n-1, 0);
	priority_queue< pair<long double,int>> pq;
	
	for(int i = 0; i<n-1; i++)
		pq.push({ arr[i+1]-arr[i], i});

	for(int i = 1 ; i<=k; i++){

		pair<int,int> currentTop = pq.top();
		pq.pop();
		
		int sIndex = currentTop.second;
		howMany[sIndex]++;

		long double sectionLen = (long double)(arr[sIndex+1] - arr[sIndex]);
		sectionLen /= (long double)( howMany[sIndex] + 1);

		pq.push({ sectionLen, sIndex});
	}

	return pq.top().first;
}





TC: nlog(n) + k*log(n)
SC: O(n){
	pq: n
	howMany: n
}


###############################################################################################

#include<bits/stdc++.h>

int findGasStations( vector<int>& arr, long double val){
	int cnt = 0, n = arr.size();
	for(int i = 0; i<n-1; i++){
		cnt += (int)((long double)(arr[i+1] - arr[i])/ val);
	}
	return cnt;
}

double minimiseMaxDistance(vector<int> &arr, int k){
	// Write your code here.	
	long double low = 0;
	long double high = 0;
	for(int num: arr)
		high = max((int)high, num);

	long double minLimit = pow(10,-6);
	while( (high-low) > minLimit){

		long double mid = ( high + low ) / 2.0;
		int noOfGasStations = findGasStations(arr, mid);
		if( noOfGasStations > k)
			low = mid;
		else
			high = mid;

	}
	return high;
}



Time Complexity: O(n*log(Len)) + O(n), n = size of the given array, Len = length of the answer space.
Reason: We are applying binary search on the answer space. For every possible answer, we are calling the function numberOfGasStationsRequired() that takes O(n) time complexity. And another O(n) for finding the maximum distance initially.

Space Complexity: O(1) as we are using no extra space to solve this problem.

