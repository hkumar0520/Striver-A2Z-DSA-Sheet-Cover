
// recursion

int f(vector<int> &nums, int target, int i, int j)
{
    if(i>j)
        return j+1;
    int mid = (i+j)/2;
    if(nums[mid] == target)
        return mid;
    else if(nums[mid]>target)
        return f(nums,target,i,mid-1);

	return f(nums,target,mid+1,j);
}

int searchInsert(vector<int>& arr, int m)
{
	// Write your code here.
    return f(arr,m, 0, arr.size()-1);
}


################################################################################################

// iteration 

int searchInsert(vector<int>& arr, int m)
{
	// Write your code here.
    int j = arr.size()-1, i=0;
    while(i<=j)
    {
        int mid = (i+j)/2;
        if(arr[mid] == m)
            return mid;
        else if(arr[mid]>m)
           j = mid-1;
        else
            i = mid+1;
    }
    return j+1;
}

### **Time and Space Complexity Analysis**  

The given function **searches for the insertion position** of `m` in a **sorted array** using **binary search**. If `m` exists, it returns its index; otherwise, it returns the position where `m` should be inserted.

---

### **Time Complexity Analysis**  
1. The function follows the **binary search pattern**, where the search space is **halved** at each step.
2. The number of iterations in the worst case is determined by how many times we can halve `n` until we reach **1**:

   \[
   n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \dots, 1
   \]

   Solving for \( k \) in \( \frac{n}{2^k} = 1 \):

   \[
   k = \log_2 n
   \]

3. Each iteration performs **constant work** \( O(1) \) (computing `mid`, comparing values, and updating `i` or `j`).

Thus, the **time complexity** is:
\[
O(\log n)
\]

---

### **Space Complexity Analysis**  
1. The function is **iterative**, meaning **no recursive call stack is used**.
2. It only uses **a few integer variables** (`i`, `j`, `mid`).

Thus, the **space complexity** is:
\[
O(1)
\]

---

### **Final Complexity Summary**  
- **Time Complexity**: \( O(\log n) \) (binary search halves the search space at each step)  
- **Space Complexity**: \( O(1) \) (only a few integer variables are used)  

This is an **optimal approach** for finding the **insertion position** in a **sorted array**. ðŸš€




