
int count(vector<int>& arr, int n, int x) {
	// Write Your Code Here
	int firstt = -1, lastt = -1, i = 0, j = n-1;
	while(i<=j)
	{
		int mid = (i+j)/2;
		if(arr[mid]>= x)
		{
			if(arr[mid] == x)
				firstt = mid;
			j = mid-1;
		}
		else
			i = mid+1;
	}
	if(firstt == -1)	return 0;
	i = 0, j=n-1;
	while(i<=j)
	{
		int mid = (i+j)/2;
		if(arr[mid]<= x)
		{
			if(arr[mid] == x)
				lastt = mid;
			i = mid+1;
		}
		else
			j = mid-1;
	}
	return (lastt - firstt +1);
}

### **Time and Space Complexity Analysis**  

The given function **counts the occurrences of `x`** in a **sorted array** using **binary search**.

---

### **Time Complexity Analysis**  
1. **The function runs two separate binary searches**:
   - The first `while` loop finds the **first occurrence** of `x`.
   - The second `while` loop finds the **last occurrence** of `x`.
   
2. Each binary search follows the **binary search pattern**, where the search space is **halved** at each step.

3. The number of iterations in each binary search is determined by how many times we can halve `n` until we reach **1**:

   \[
   n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \dots, 1
   \]

   Solving for \( k \) in \( \frac{n}{2^k} = 1 \):

   \[
   k = \log_2 n
   \]

4. Since there are **two binary searches**, the **total time complexity** is:

   \[
   O(\log n) + O(\log n) = O(2 \log n) = O(\log n)
   \]

---

### **Space Complexity Analysis**  
1. The function is **iterative**, meaning **no recursive call stack is used**.
2. It only uses **a few integer variables** (`i`, `j`, `mid`, `firstt`, `lastt`).
3. The function returns an **integer count**, which takes **\( O(1) \) space**.

Thus, the **space complexity** is:
\[
O(1)
\]

---

### **Final Complexity Summary**  
- **Time Complexity**: \( O(\log n) \) (two binary searches, each taking \( O(\log n) \))  
- **Space Complexity**: \( O(1) \) (only a few integer variables are used)  

This is an **optimal approach** for counting occurrences of an element in a **sorted array**. ğŸš€


