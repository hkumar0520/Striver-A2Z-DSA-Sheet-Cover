

#include <bits/stdc++.h>

int findKRotation(vector<int> &arr){
    // Write your code here.  
    int ans = INT_MAX, i = 0, j = arr.size()-1, index = -1;
    while(i<=j)
    {
        int mid = (i+j)/2;

        if(arr[i]<=arr[j])
        {
            if(arr[i]<= ans)
            {
                ans = arr[i];
                index = i;
            }
            break;
        }

        if(arr[i]<=arr[mid])
        {
            if(arr[i]<= ans)
            {
                ans = arr[i];
                index = i;
            }
            i = mid+1;
        }
        else
        {
            if(arr[mid]<= ans)
            {
                ans = arr[mid];
                index = mid;
            }
            j = mid-1;
        }
    }
    return index;  
}



##################################################################################################



class Solution {
  public:
    int findKRotation(vector<int> &arr) {
        // Code Here
        
	// Write your code here.
	int n = arr.size();
	int i=0,j = n-1, ans = INT_MAX, minIndex = -1;
    while(i<=j)
    {
        int mid = (i+j)/2;
        
        if(arr[i]<=arr[mid])
        {
            if(arr[i] < ans){
                minIndex = i;
                ans = min(ans,arr[i]);
            }
            i = mid+1;
        }
        else
        {
            if(arr[mid] < ans){
                minIndex = mid;
                ans = min(ans,arr[mid]);
            }
            j = mid-1;
        }
        
    }
	return minIndex;  
        
    }
};

Let's analyze the **time and space complexity** of the given C++ function.

---

### **Time Complexity Analysis**
The function is finding the index of the minimum element in a **rotated sorted array** using a **binary search** approach.

1. The array is divided into two halves in each iteration.
2. The search space is reduced by half at every step.
3. Since the problem follows a binary search approach, the number of iterations is at most **logâ‚‚(N)**.

Thus, the **time complexity is O(log N)**.

---

### **Space Complexity Analysis**
- The algorithm only uses a few integer variables (`i, j, ans, minIndex, mid`).
- No extra data structures are used except for the input array (which is given as an argument).
- No recursion is used (which could add stack space overhead).

Thus, the **space complexity is O(1)**, as the algorithm runs in constant extra space.

---

### **Final Complexity**
- **Time Complexity:** **O(log N)**
- **Space Complexity:** **O(1)**

This is an efficient approach to finding the index of the minimum element (i.e., the number of rotations in a rotated sorted array). ðŸš€


