
// recursion

void f(vector<int> arr, int x, int i, int j, int &floorr, int &ceill)
{
	if(i>j)
		return ;
	
	int mid = (i+j)/2;
	if(arr[mid] == x)
		floorr = ceill = arr[mid];
	else if(arr[mid] > x)
	{
		ceill = arr[mid];
		f(arr,x,i,mid-1,floorr, ceill);
	}
	else
	{	
		floorr = arr[mid];
		f(arr,x,mid+1,j, floorr, ceill);
	}
	return ;
}

pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
	// Write your code here.
	int floorr = -1, ceill = -1,i = 0, j= n-1;
	f(a,x,0,n-1,floorr, ceill);
	return pair<int,int>{floorr, ceill};
}

################################################################################################

// iteration

pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
	// Write your code here.
	int floorr = -1, ceill = -1,i = 0, j= n-1;
	while(i<=j)
	{
		int mid = (i+j)/2;
		if(a[mid] == x)
			return pair<int,int>{a[mid], a[mid]};
		else if(a[mid] > x)
		{
			ceill = a[mid];
			j = mid-1;
		}
		else
		{
			floorr = a[mid];
			i = mid+1;
		}
	}
	return pair<int,int>{floorr, ceill};
}


### **Time and Space Complexity Analysis**  

The given function **finds the floor and ceiling** of `x` in a **sorted array** using **binary search**.

---

### **Time Complexity Analysis**  
1. The function follows the **binary search pattern**, where the search space is **halved** at each step.
2. The number of iterations in the worst case is determined by how many times we can halve `n` until we reach **1**:

   \[
   n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \dots, 1
   \]

   Solving for \( k \) in \( \frac{n}{2^k} = 1 \):

   \[
   k = \log_2 n
   \]

3. Each iteration performs **constant work** \( O(1) \) (computing `mid`, comparing values, and updating `i` or `j`).

Thus, the **time complexity** is:
\[
O(\log n)
\]

---

### **Space Complexity Analysis**  
1. The function is **iterative**, meaning **no recursive call stack is used**.
2. It only uses **a few integer variables** (`i`, `j`, `mid`, `floorr`, `ceill`).
3. The function **returns a pair** of integers, which takes **\( O(1) \) space**.

Thus, the **space complexity** is:
\[
O(1)
\]

---

### **Final Complexity Summary**  
- **Time Complexity**: \( O(\log n) \) (binary search halves the search space at each step)  
- **Space Complexity**: \( O(1) \) (only a few integer variables are used)  

This is an **optimal approach** for finding the **floor and ceiling** in a **sorted array**. ðŸš€



