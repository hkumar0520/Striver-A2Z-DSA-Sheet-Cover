

class Solution {
  public:

    int findFloor(vector<int>& arr, int m) {

        // Your code here
    int j = arr.size()-1, i=0, floorr = -1;
    while(i<=j)
    {
        int mid = (i+j)/2;
        if(arr[mid]>m)
           j = mid-1;
        else{
            floorr =  mid;
            i = mid+1;
        }
    }
    return floorr;  // return j
    }
};


The given code implements **binary search** to find the **floor** of a given number \( m \) in a sorted array. Let's analyze its **time complexity** and **space complexity**.

---

### **Understanding the Floor Function**
The **floor** of \( m \) in a sorted array is the **greatest element that is less than or equal to \( m \)**.

- If `arr[mid] > m`, search the **left half** (`j = mid - 1`).
- Otherwise, update `floorr` to `mid` and search the **right half** (`i = mid + 1`).
- The final value of `floorr` is the index of the floor element.

---

### **Time Complexity Analysis**
1. The function follows the **binary search pattern**, where the search space is **halved** at each step.
2. The number of iterations in the worst case is determined by how many times we can halve `n` until we reach **1**:

   \[
   n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \dots, 1
   \]

   Solving for \( k \) in \( \frac{n}{2^k} = 1 \):

   \[
   k = \log_2 n
   \]

3. Each iteration performs **constant work** \( O(1) \) (computing `mid`, updating `floorr`, and adjusting `i` or `j`).

Thus, the **time complexity** is:
\[
O(\log n)
\]

---

### **Space Complexity Analysis**
1. The function is **iterative**, meaning **no recursive call stack is used**.
2. It uses **only a few integer variables** (`i`, `j`, `mid`, `floorr`).

Thus, the **space complexity** is:
\[
O(1)
\]

---

### **Final Complexity Summary**
- **Time Complexity**: \( O(\log n) \) (binary search halves the search space at each step)
- **Space Complexity**: \( O(1) \) (only a few integer variables are used)

This is an **optimal approach** for finding the **floor** in a **sorted array** because it achieves **logarithmic time and constant space complexity**. ðŸš€

