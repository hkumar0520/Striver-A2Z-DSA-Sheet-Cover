

https://www.geeksforgeeks.org/problems/k-closest-elements3619/1

class Solution {
  public:
    int upperBoundd(vector<int>& arr, int n, int x){
        int low = 0, high = n-1;
        while(low <= high){
            int mid = (low + high)/2;
            
            if(arr[mid] > x)
                high = mid-1;
            else
                low = mid + 1;
        }
        // return ub (0 or n) in case of extreme scenario
        return low;
    }
    vector<int> printKClosest(vector<int> arr, int n, int k, int x) {
        // code here
        int uBIndex = upperBoundd(arr, n, x);
        int low = uBIndex, high = uBIndex;
        
        if(uBIndex == n){
            low--;
            while(low >=0 && arr[low] >= x)
                low--;
            
        }
        else if(uBIndex == 0){
            low = -1;
            while(high < n && arr[high] == x)
                high++;
        }
        else{
            while(low >=0 && arr[low] >= x)
                low--;
        
            while(high < n && arr[high] == x)
                high++;
        }
        
            
        vector<int> ans;
        int limitK = k;
        while(limitK--){
            int valLow = INT_MAX;
            if(low >= 0)
                valLow = abs(x - arr[low]);
                
            int valHigh = INT_MAX;
            if(high < n)
                valHigh = abs(x - arr[high]);
            
            if(valHigh <= valLow){
                ans.push_back(arr[high]);
                high++;
            }
            else{
                ans.push_back(arr[low]);
                low--;
            }
            
            if(low<0 && high>=n)
                break;
        }
        return ans;
    }
};


TC: O(log(N) + K)
SC: O(K)

######################################################################


class Solution {
  public:
    int upperBoundd(vector<int>& arr, int n, int x){
        int low = 0, high = n-1;
        while(low <= high){
            int mid = (low + high)/2;
            
            if(arr[mid] > x)
                high = mid-1;
            else
                low = mid + 1;
        }
        // return ub (0 or n) in case of extreme scenario
        return low;
    }
    vector<int> printKClosest(vector<int> arr, int n, int k, int x) {
        // code here
        int uBIndex = upperBoundd(arr, n, x);
        int low = uBIndex-1, high = uBIndex;
        
        while(low >=0 && arr[low] >= x)
            low--;
            
        vector<int> ans;
        int limitK = k;
        while(limitK--){
            int valLow = INT_MAX;
            if(low >= 0)
                valLow = abs(x - arr[low]);
                
            int valHigh = INT_MAX;
            if(high < n)
                valHigh = abs(x - arr[high]);
            
            if(valHigh <= valLow){
                ans.push_back(arr[high]);
                high++;
            }
            else{
                ans.push_back(arr[low]);
                low--;
            }
            
            if(low<0 && high>=n)
                break;
        }
        return ans;
    }
};



######################################################################

// User function template for C++

class Solution {
  public:
    int upperBoundd(vector<int>& arr, int n, int x){
        int low = 0, high = n-1;
        while(low <= high){
            int mid = (low + high)/2;
            
            if(arr[mid] > x)
                high = mid-1;
            else
                low = mid + 1;
        }
        // return ub (0 or n) in case of extreme scenario
        return low;
    }
    int lowerBoundd(vector<int>& arr, int n, int x){
        int low = 0, high = n-1;
        while(low <= high){
            int mid  = ( low + high)/2;
            
            if(arr[mid] >= x)
                high = mid-1;
            else
                low = mid + 1;
        }
        return low;
    }
    vector<int> printKClosest(vector<int> arr, int n, int k, int x) {
        // code here
        int uBIndex = upperBoundd(arr, n, x);
        int lBInex = lowerBoundd(arr, n, x);
        int low = lBInex-1, high = uBIndex;
        
            
        vector<int> ans;
        int limitK = k;
        while(limitK--){
            int valLow = INT_MAX;
            if(low >= 0)
                valLow = abs(x - arr[low]);
                
            int valHigh = INT_MAX;
            if(high < n)
                valHigh = abs(x - arr[high]);
            
            if(valHigh <= valLow){
                ans.push_back(arr[high]);
                high++;
            }
            else{
                ans.push_back(arr[low]);
                low--;
            }
            
            if(low<0 && high>=n)
                break;
        }
        return ans;
    }
};








