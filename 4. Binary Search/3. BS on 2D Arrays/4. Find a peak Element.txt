

1. Brute force ( rowLen*colLen , 1)
2. optimal ( rowLen*log(colLen) , 1)


class Solution {
public:
    int findLargeRow(vector<vector<int>>& mat, int rowLen, int colLen, int mid){
        int row = 0;
        for(int i = 0; i<rowLen; i++){
            if(mat[i][mid] > mat[row][mid])
                row = i;
        }
        return row;
    }
    vector<int> findPeakGrid(vector<vector<int>>& mat) {

        int rowLen = mat.size(), colLen = mat[0].size();
        int low = 0, high = colLen-1;

        while(low <= high){
            int mid = (low + high)/2;

            int rowLarge = findLargeRow(mat, rowLen, colLen, mid);
            int leftElement = mid > 0 ? mat[rowLarge][mid-1] : INT_MIN;
            int rightElement = mid < (colLen-1) ? mat[rowLarge][mid+1] : INT_MIN;

            if( (mat[rowLarge][mid] > leftElement) && (mat[rowLarge][mid] > rightElement))
                return {rowLarge, mid};
            else if( mat[rowLarge][mid] < leftElement)
                high = mid-1;
            else if( mat[rowLarge][mid] < rightElement)
                low = mid+1;
        }
        return {-1, -1};
    }
};


TC: rowLen * log(colLen)
SC: O(1)



